# 简单博弈论



## Nim游戏

若一个游戏满足：

1、由两名玩家交替行动

2、在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关

3、不能行动的玩家判负

则称该游戏为一个公平组合游戏。

尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

### 题目描述

给定n堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

例如：有两堆石子，第一堆有2个，第二堆有3个，先手必胜。

#### 操作步骤：

1. 先手从第二堆拿走1个，此时第一堆和第二堆数目相同

2. 无论后手怎么拿，先手都在另外一堆石子中取走相同数量的石子即可。

#### 必胜状态和必败状态

在解决这个问题之前，先来了解两个名词：

1. 必胜状态，先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。

   即先手可以走到某一个必败状态。

2. 必败状态，先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。

   即先手走不到任何一个必败状态。

### 证明

操作到最后时，每堆石子数都是$0$，$0⊕0⊕…0=0$

在操作过程中，如果 $a1⊕a2⊕…⊕an=x≠0$。

那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为$0$。

证明：不妨设x的二进制表示中最高一位$1$在第$k$位，

那么在$a1,a2,…,ana1,a2,…,an$中，必然有一个数$a$i，它的第$k$为时$1$，

且$ai⊕x<ai$，那么从第$i$堆石子中拿走$(ai−ai⊕x)$个石子，第$i$堆石子还剩$ai⊕x$，

此时$a1⊕a2⊕…⊕ai⊕x⊕…⊕an=x⊕x=0$

在操作过程中，如果$ a1⊕a2⊕…⊕an=0$，那么无论玩家怎么拿，必然会导致最终异或结果不为0。

#### 反证

假设玩家从第i堆石子拿走若干个，结果仍是$0$。

不妨设还剩下$a$′个，因为不能不拿，所以$0≤a′<ai$，且$a1⊕a2⊕…⊕a′⊕…⊕an=0$。

那么$(a1⊕a2⊕…⊕ai⊕…an)⊕(a1⊕a2⊕…⊕a′⊕…⊕an)=ai⊕a′=0$，

则 $ai=a′$，与假设$0≤a′<ai$矛盾。

#### 基于上述三个证明：

1. 如果先手面对的局面是$a1⊕a2⊕…⊕an≠0$，

   那么先手总可以通过拿走某一堆若干个石子，将局面变成$a1⊕a2⊕…⊕an=0$。

   如此重复，最后一定是后手面临最终没有石子可拿的状态。先手必胜。

2. 如果先手面对的局面是$a1⊕a2⊕…⊕an=0$，

   那么无论先手怎么拿，都会将局面变成$a1⊕a2⊕…⊕an≠0$，

   那么后手总可以通过拿走某一堆若干个石子，将局面变成$a1⊕a2⊕…⊕an=0$。

   如此重复，最后一定是先手面临最终没有石子可拿的状态。先手必败。

### 结论

假设$n$堆石子，石子数目分别是$a1$,$a2$,…,$an$

如果$a1⊕a2⊕…⊕an≠0$，先手必胜；否则先手必败。

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int res=0;
    while(n--)
    {
        int x;
        cin>>x;
        res^=x;
    }
    
    if(res) cout<<"Yes";
    else cout<<"No";
    
    return 0;
}
```

## 台阶-Nim游戏

### 题目描述

现在，有一个 $n$ 级台阶的楼梯，每级台阶上都有若干个石子，其中第 $i$ 级台阶上有 $ai$ 个石子 $(i≥1)$。

两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

### 输入格式

第一行包含整数 $n$。

第二行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 级台阶上的石子数 $ai$。

### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

### 数据范围

$1≤n≤10$^5^,
$1≤ai≤10$^9^

### 解题思路

#### 结论

奇数台阶上的石子数异或起来，不等于0先手必赢，否则先手必败。

#### 证明

先手时，如果奇数台阶异或非0，根据经典Nim游戏，先手总有一种方式使奇数台阶异或为0，于是先手留了奇数台阶异或为0的状态给后手

于是轮到后手：
①当后手移动偶数台阶上的石子时，先手只需将对手移动的石子继续移到下一个台阶，这样奇数台阶的石子相当于没变，于是留给后手的又是奇数台阶异或为0的状态
②当后手移动奇数台阶上的石子时，留给先手的奇数台阶异或非0，根据经典Nim游戏，先手总能找出一种方案使奇数台阶异或为0

（核心就是：先手总是把奇数台阶异或为0的状态留给对面，即总是将必败态交给对面）

### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    int res=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        if(i%2) res^=x;
    }
    if(res) cout<<"Yes";
    else cout<<"No";
    return 0;
}
```



## Mex运算

设S是一个非负整数集合，求出不属于集合S的最小非负整数的运算。

## SG函数

点x的SG值 等于 x能到达的点(相邻的点)的SG值组成的集合的Mex值

SG(x) == Mex{ SG(y~1~),SG(y~2~) ... SG(y~n~) }

SG(终点) == 0;

### 单图情况

必败态：SG(起点) = 0

必胜态：SG(起点) ≠ 0

### 多图情况

n个图的起点的SG值异或的结果是0的话必败，否则必胜。



### 集合-Nim游戏

#### 题目描述

给定 $n$ 堆石子以及一个由 $k$ 个不同正整数构成的数字集合 $S$。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 $S$，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数$ k$，表示数字集合 $S$ 中数字的个数。

第二行包含 $k $个整数，其中第$ i $个整数表示数字集合 S 中的第$ i $个数$ si$。

第三行包含整数$ n$。

第四行包含$ n$ 个整数，其中第$ i $个整数表示第$ i$堆石子的数量$ hi$。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

$1≤n,k≤100$
$1≤si,hi≤10000$



```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=1e5+10;
int s[N];//s存储每次可以拿石子的个数
int h[M];//h存储每堆石子的个数
int k,n;
int sg(int x)
{
    //因为每次可以拿走石子的个数是确定的 所以一个数的SG值也是确定的
    //如果存储过了 就直接返回
    if(h[x]!=-1) return h[x];
    unordered_set <int> S;//存放x能到达的点的SG值
    for(int i=0;i<k;i++)
    {
        int num=s[i];
        //递归到无路可走 从后往前求出SG(x-num) 再插入到S中
        if(x>=num) S.insert(sg(x-num));
    }
    //求Mex 这里的i只是key值 
    //从0开始遍历 如果对应的val==0 那么这个key就是最小没出现的数
    for(int i=0; ;i++)
        if(S.count(i) == 0) return h[x]=i;
}
int main()
{
    cin>>k;
    for(int i=0;i<k;i++) cin>>s[i];
    cin>>n;
    //初始化-1 方便在sg函数中查看x是否被记录过
    memset(h,-1,sizeof h);
    //遍历n堆石子 res异或sg(起点) 
    int res=0;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        res^=sg(x);
    }
    
    if(res) cout<<"Yes";
    else cout<<"No";

    return 0;
}
```

## 拆分-Nim游戏

#### 问题描述

给定 $n$ 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆**规模更小**的石子（新堆规模可以为 $0$，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数 $n$。

第二行包含 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 堆石子的数量 $ai$。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

$1≤n,ai≤100$

#### AC代码















 