# 01x00 Scope of Software Engineering



## 01x01 software crisis

1968

### Aim

solve the software crisis

### Software is delivered

1. Late 过时
2. Over budget 超预算
3. With residual faults 残余缺点



## 01x02 economic

### use 10% faster method

Consider the cost of training

Consider the  impact of introducing a new technology

Consider the effect of $CMnew$ on maintenance 	 



## 01x03 maintenance

### Life-cycle model

1. The steps (phases) to follow when building software
2. A theoretical description of what should be done

### Life cycle

The actual steps performed on a specific product

### Waterfall Life-Cycle Model(1970)

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230904145710639.png" alt="image-20230904145710639" style="zoom: 25%;" />

#### Requirements phase

1. Explore the concept
2. Elicit the client’s requirements

#### Analysis (specification) phase

1. Analyze the client’s requirements

2. Draw up the specification document

3. Draw up the software project management plan

4. “What the product is supposed to do”

#### Design phase

1. Architectural design, followed by
2. Detailed design“How the product does it”

#### Implementation phase

1. Coding
2. Unit testingIntegration
3. Acceptance testing

#### Postdelivery maintenance

1. Corrective maintenance

2. Perfective maintenance
3. Adaptive maintenance

#### Retirement



### Classical Maintenance

#### development-then-maintenance model

development or maintenance depends on **when** an activity is performed.

#### problem

Development from scratch is rare today

Reuse is widespread



### Modern Maintenance

maintenance occurs when software is modified, whether before or after installation



### Importance of Postdelivery Maintenance

1. Bad software is discarded
2. Good software is maintained, for 10, 20 years, or more
3. Software is a model of reality, which is constantly changing

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230906160411801.png" alt="image-20230906160411801" style="zoom: 25%;" />



## 01x04 Requirements, Analysis, and Design Aspects

The earlier we detect and correct a fault, the less it costs us

### The cost of corret a fault in different time

#### To correct a fault early in the life cycle

Usually just a document needs to be changed

#### To correct a fault late in the life cycle

1. Change the code and the documentation
2. Test the change itself
3. Perform regression回归 testing
4. Reinstall the product on the client’s computer(s)

### Conclusion

Between 60 and 70% of all faults in large-scale products are requirements, analysis, and design faults

1. To find faults as early as possible

2. To reduce the overall总 number of faults (and, hence, the overall cost)



## 01x05 Team Programming

1. Hardware is cheap
2. Software is built by teams
   1. Interfacing problems between modules
   2. Communication problems among team members



## 01x06 Why There Is No Planning Phase

We cannot plan at the beginning of the project —we do not yet know exactly what is to be built

### Conclusion

1. Planning activities are carried out throughout the life cycle
2. There is no separate单独的 planning phase



## 01x07 Why There Is No Testing Phase

It is far too late to test after development and before delivery

### Conclusion

1. Continual testing activities must be carried out throughout the life cycle
2. This testing is the responsibility of Every software professional, and The software quality assurance group
3. There is no separate testing phase



## 01x08 Why There Is No Documentation Phase

It is far too late to document after development and before delivery

### Documentation Must Always be Current

1. Key individuals may leave before the documentation is complete
2. We cannot perform a phase without having the documentation of the previous phase
3. We cannot test without documentation
4. We cannot maintain without documentation

### Conclusion

1. Documentation activities must be performed in parallel同时的 with all other development and maintenance activities
2. There is no separate documentation phase   



## 01x09 The Object-Oriented Paradigm

A software component that incorporates both data and the actions that are performed on that data

### Background

1.  structured methods fail with larger products (> 50,000 LOC)
2. Postdelivery maintenance problems (today, 70 to 80% of total effort)
3. Structured methods only are Action oriented or Data ariented, not Both.
4. Both data and actions are of equal importance

### Feature

1. information hiding
2. responsibility - driven desigh
3. impact on maintenance, development

### Strengths

1. postdelivery maintenance is safer
2. Development is easier
3. Well-designed objects are independent units
4. a classical product conceptually consists of a single unit
5. The object-oriented paradigm promotes reuse



### Analysis/Design "Hump"

#### In the classical paradigm

1. Classical analysis
   - Determine what has to be done
2. Design
   - Determine how to do it
   - Architectural design — determine the modules
   - Detailed design — design each module

#### In the object-oriented paradigm

1. object-oriented analysis
   - determine what has to be done
   - determine the objects
2. object-oriented design
   - determine how to do it
   - design the objects



Modules (objects) are introduced as early as the object-oriented analysis workflow 

The objects are then coded during the implementation workflow



## 01x10 The Object-Oriented Paradigm in Perspective

1. The object-oriented paradigm has to be used correctly

2. When used correctly, the object-oriented paradigm can solve some (but not all) of the problems of the classical paradigm
3. The object-oriented paradigm has problems of its own
4. The object-oriented paradigm is the best alternative available today



## 01x11 Terminology

Client, developer, user

Internal software 内部软件

Contract software 合同授权软件

Commercial off-the-shelf (COTS) software 商用现货软件

Open-source software

Software 

Program, system, product 

Methodology, paradigm

- Object-oriented paradigm

- Classical (traditional) paradigm

Technique

Mistake, fault, failure, error

Defect 缺点

Bug错误



### OOP

Data component of an object

- State variable 状态变量

- Instance variable (Java) 实例变量

- Field (C++) 字段

- Attribute (generic) 属性

Action component of an object

- Member function (C++) 成员方法

- Method (generic) 方法

C++: A member is either an

- Attribute (“field”), or aMethod (“member function”)

Java: A field is either an

- Attribute (“instance variable”), or aMethod



# 02x00 Software Life-cycle Models



## 02x01 Software Development

#### In Theory理论

- linear线性的
- starting from scratch从头开始

#### In Practice, really world

- mistakes
- requirements changed



## 02x02 Winburg Mini Case Study

### Evolution Tree Model

- the explicit显示地 order of events is shown
- at the end of episode事件 have baseline基线

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230913213441804.png" alt="image-20230913213441804" style="zoom: 33%;" />

### Waterfall Model

- the linear life cycle model with feedback loops
- cannot show the order of events

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230913213633743.png" style="zoom:25%;" />



## 02x03 Lessons of the Winburg Mini Case Study

- in the real world, development is more chaotic无序的 than the mini case study.

- changes are always needed
  - software product is changing
  - software developer mistakes



## 02x04 Teal Tractors Mini Case Study

### requirements changes may be

- Great for the company
- Disastrous灾难 for the software product

### Moving Target Problem

- a change in the requestments while the software product is being developed
- even if the reasons for the change are good, the software product can be adversely不利的 impacted
  - dependencies依赖关系 will be induced诱导
- any change made to a software product can potentially潜在的 cause a regression回归 fault错误
  - a fault in an apparently明显 unrelated不相关 part of the software
- if there are too many changes, the entire product may have to be redesigned and reimplemented
- change is inevitable不可避免
- there is no solution to the moving target problem



## 02x05 Iteration迭代 and Incrementation增量

- in real time, we cannot speak about [analysis phase]
  - analysis over the life cycle
- the basic software development process is iteration迭代的
  - each latest version is intended to be closer to its target
- Iteration and incrementation are used in conjunction互相结合 with one another
- The number of increments will vary变化
- iteration迭代 is performed during each incrementation
- the number of iterations will vary



### Miller's Law



- at any one time, we can concentrate专注 on only approximately seven chunks
- to handle larget amounts of information, use stepwise refinement逐步细化
  - Concentrate集中 on the aspects that are currently the most important
  - Postpone推迟 aspects that are currently less critical重要
  - Every aspect is eventually handled, but in order of current importance  
- this is an incremental渐进process



### Classical Phases Vs Workflows



- Sequential连续 phases do not exist in the real world
- Instead, the five core workflows (activities) are performed over the entire life cycle



### Workflows



- five core workflow are perfomed over entire life cycle
- at most time one workflow predominates占主导
- Planning and documentation activities are performed throughout the life cycle



## 2.6  The Winburg Mini Case Study Revisited

- Consider the next slide
- The evolution-tree model has been superimposed on the iterative-and-incremental life-cycle model
- The test workflow has been omitted — the evolution-tree model assumes continuous testing

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230917205651425.png" style="zoom: 33%;" />



### More on Incrementation



- each episode corresponds to an increment
- not every increment includes every workflow
- increment B was not completed
- Dashed lines denote maintenance





## 02x07 Risks and Other Aspects of Iter. & Increm.

- We can consider the project as a whole as a set of mini projects (increments)
- Each mini project extends the 
  - Requirements artifacts
  - Analysis artifacts
  - Design artifacts
  - Implementation artifacts
  - Testing artifacts 
- The final set of artifacts is the complete（完整的） product
- During each mini project we 
  - Extend the artifacts (incrementation); 
  - Check the artifacts (test workflow); and
  - If necessary, change the relevant artifacts (iteration)
- Each iteration can be viewed as a small but complete waterfall life-cycle model
- During each iteration we select a portion of the software product
- On that portion we perform the
  - Classical requirements phase
  - Classical analysis phase
  - Classical design phase
  - Classical implementation phase



### Strengths of the Iterative-and-Incremental Model



- There are multiple opportunities for checking that the software product is correct
  - Every iteration incorporates （包含）the test workflow
  - Faults can be detected and corrected early
- The robustness（稳健性） of the architecture can be determined early in the life cycle
  - Architecture — the various component modules and how they fit together
  - Robustness — the property of being able to handle extensions and changes without falling apart （不会崩溃）
- We can mitigate (resolve)（减轻/解决) risks early
  - Risks are invariably involved in software development and maintenance
- We have a working version of the software product from the start
  - The client and users can experiment with this version to determine what changes are needed
- Variation: Deliver partial versions to smooth the introduction of the new product in the client organization
- There is empirical evidence(经验数据表明） that the life-cycle model works
- The CHAOS reports of the Standish Group (see overleaf) show that the percentage of successful products increases



## 2.8  Managing Iteration and Incrementation

The iterative-and-incremental life-cycle model is as regimented as the waterfall model 

…… because the iterative-and-incremental life-cycle model is the waterfall model, applied successively

Each increment is a waterfall mini project

## 02x09 Other Life-cycle Models



### Code-and-fix life-cycle model 代码修复



#### Characterized

- No design
- No specifications说明书



#### 优点

- The easiest way to develop software



#### 缺点

- the most expensive way

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230914141250780.png" alt="image-20230914141250780" style="zoom: 25%;" />



### waterfall life-cycle model 



#### Characterized

- Feedback loops
- Documenttation-driven



#### Advantages

- Documentation
- Maintenance is easier



#### Disadvantages



- Specification document 自然语言书写有歧义

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230914141400804.png" alt="image-20230914141400804" style="zoom:25%;" />



### Rapid prototyping life-cycle model 快速原型



#### Characterized

- Linear model
- Rapid

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230914143047284.png" alt="image-20230914143047284" style="zoom:25%;" />



### open-source life-cycle model



- two informal phases
- First, one individual builds an initial version
  - Made available via the Internet
- Then, if there is sufficent interest in the project
  - The initial version is widely downloaded
  - Users become co-developers
  - The product is extended
- Key point : individuals generally work voluntarily on an opensource project in their spare time



#### Second informal phase



<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/image-20230914144914864.png" alt="image-20230914144914864" style="zoom:25%;" />



- closed-source software is maintained and tested by employees
- open-source software is generally maintained by unpaid volunteers
- closed-source software released roughly once a year
- open-source software released early and often



#### an initial working version is produced when using



- rapid-prototyping model
- code-and-fix model
- open-source model



#### then 



- rapid-prototyping model
  - the inital version is discarded丢弃的
- Code-and-fix model and open-source model
  - the inital version becomes the target product目标产品



### agile processes life-cycle model 敏捷过程

#### Core group



#### peripheral group



### Synchronize-and-stabilize life-cycle model

### Spiral life-cycle model
