# 递归

#### 所有的递归都可以转换成递归搜索树

这里我们拿斐波那契数列举例画图。

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/202210221136934.png" style="zoom:50%;" />

## 简单斐波那契

输出前 $n$ 个斐波那契数。斐波那契初始 `0,1,1,2,3`

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int a=0,b=1;
    for(int i=0;i<n;i++)
    {
        cout<<a<<' ';
        int c=a+b;
        a=b,b=c;//挪位
    }
    return 0
}
```



## 递归实现指数型枚举

转化为递归搜索树，利用一个数组表示两种状态选或不选，所有情况遍历一遍后再根据选或不选进行输出。核心为$DFS$ 回溯（恢复现场）。

#### 问题描述

从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。

#### 输入格式

输入一个整数 $n$。

#### 输出格式

每行输出一种方案。

同一行内的数必须升序排列，相邻两个数用恰好 $1$ 个空格隔开。

对于没有选任何数的方案，输出空行。

本题有自定义校验器$（SPJ）$，各行（不同方案）之间的顺序任意。

#### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=16;
int n, st[N];//状态：记录每个位置当前的状态：0表示还没考虑、1表示被选、2表示不选
void dfs(int u)
{
    if(u>n)
    {
        for(int i=1;i<=n;i++)
            if(st[i]==1) cout<<i<<' ';
        cout<<endl;
        return;
    }

    st[u]=2;
    dfs(u+1);//第一个分支不选
    st[u]=0;//恢复现场

    st[u]=1;
    dfs(u+1);//第二个分支 选
    st[u]=0;

}
int main()
{
    cin>>n;

    dfs(1);

    return 0;
}
```



## 递归实现排列型枚举

把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。

#### 输入格式

一个整数 $n$。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

#### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=10;
int n,num[N];
bool st[N];
void dfs(int u)
{
    if(u>n)
    {
        for(int i=1;i<=n;i++) cout<<num[i]<<' ';
        cout<<endl;
        
        return;
    }
    
    for(int i=1;i<=n;i++)
    {
        if(st[i]==false)
        {
            num[u]=i;//选这个数
            st[i]=true;//标记
            dfs(u+1);//下一位
            num[u]=0;
            st[i]=false;//恢复现场
        }
    }
}
int main()
{
    cin>>n;
    
    dfs(1);
    
    return 0;
}
//蓝桥杯课程第一节课有DFS时间复杂度的讲解
```

## 递归实现组合型枚举

从 $1∼n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。

#### 输入格式

两个整数 $n,m$ ,在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

$n>0$
$0≤m≤n$ ,
$n+(n−m)≤25$

#### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=50;
int n,m;
int num[N];
//start表示当前最小可以从哪个数开始枚举 
//因为本题是求递增的 所以只要是满足递增 就不会出现重复的数 所以就不用标记状态
void dfs(int u,int start)
{
    if(u-1+n-start+1<m) return;//剪枝优化
    //当前选了u-1个数 加上后面能有n-start+1个数之和小于要选的m个数的时候 就不满足呢 就要优化
    if(u>m)
    {
        for(int i=1;i<=m;i++) cout<<num[i]<<' ';
        cout<<endl;
        return;
    }

    for(int i=start;i<=n;i++)
    {
        num[u]=i;
        dfs(u+1,i+1);//当前位上的数i加1是下一位的start
        num[u]=0;
    }
}
int main()
{
    cin>>n>>m;

    dfs(1,1);

    return 0;
}
```

#### 剪枝优化

在DFS中如果能有判断让DFS提前退出就能优化时间，他叫剪枝。此题中可以算出来，当start到n的个数+已经选择的个数<m个的时候就已经必然无解了就退出。`u-1+n-start+1<m` 。这样的一个优化算法，经过实验得出，能优化一半的时间。

## 带分数

#### 问题描述

$100$ 可以表示为带分数的形式：$100=3$+$69258$ / $714$

还可以表示为：$100=82$+$3546$ / $197$

注意特征：带分数中，数字 $1∼9$ 分别出现且只出现一次（不包含 $0$）。

类似这样的带分数，$100$ 有 $11$ 种表示法。

#### 解题思路

1. 枚举  1~9 全排列
2. 用两个隔板把全排列成三部分a,b,c。
3. 把a,b,c区间数组分别转化成数。
4. 最后试算是否满足公式，满足加一。
5. 输出结果。

#### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
int n,cnt;
int num[10];
bool st[10];

int god(int l,int r)//把区间数组转化为数
{
    int res=0;
    for(int i=l;i<=r;i++)
    {
        res=res*10+num[i];
    }
    return res;
}

void dfs(int u)
{
    if(u>9)
    {
        for(int i=1;i<=7;i++)
        {
            for(int j=i+1;j<=8;j++)
            {
                int a,b,c;
                a=god(1,i);
                b=god(i+1,j);
                c=god(j+1,9);
                if(n*c==a*c+b) cnt++;
            }
        }
        return;
    }
    
    for(int i=1;i<=9;i++)
    {
        if(!st[i])
        {
            num[u]=i;
            st[i]=true;
            dfs(u+1);
            st[i]=false;
        }
    }
}

int main()
{
    cin>>n;
    
    dfs(1);
    
    cout<<cnt;
    return 0;
}
```

# 递推



## 费解的开关

### 题目描述

$25$ 盏灯排成一个 $5×5$ 的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

### 分析

1. 按灯开关的顺序可以任意
2. 每个灯的开关最多只能按一次，按两次相当于没按
2. 每一行开关的操作是由上一行灯的亮灭状态所决定
4. 上边的灯如果是亮的它下边一定不按开关
5. 上边的灯如果是灭的他下边必须需要按
6. 最后一行的状态无法改变

### 操作

1. 枚举第一行
2. 在根据第一行的亮灭决定下一行的灯的亮灭操作
3. 判断最后一行是否全亮

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=6;
char g[N][N],backup[N][N];
int dx[5]={1,-1,0,0,0},dy[5]={0,0,0,1,-1};
//枚举四个方向
void turn(int x,int y)
{
    for(int i=0;i<5;i++)
    {
        int a=x+dx[i],b=y+dy[i];
        if(a<0 || a>4 || b<0 || b>4) continue;
        g[a][b]^=1;//因为字符0和1的阿斯科马是48、49 
        //二进制下只差一位 亦或后变成彼此
    }
}

int main()
{
    int q;
    cin>>q;

    while(q--)
    {
        for(int i=0;i<5;i++) cin>>g[i];
		memcpy(backup,g,sizeof g);//先拷贝到备份数组 本次结束后用于还原g数组
        
        int res=10;
        //从编号1-4这四行每个灯泡是否需要按都是由上一行的灯泡的亮灭决定的
        //然而只有第0行起着关键作用 如果你直接从1~4枚举看上一行的亮灭 这样可能会错失最优解
        //因为第0行你还没有按 漏掉了情况 
        //所以我们用op(0~31)二进制来表示这次操作第0行谁需要被按
        //这样我们就有了第0行的32种固定方法
        for(int op=0;op<32;op++)
        {
            int step=0;
            for(int i=0;i<5;i++)//枚举第一行的每个开关
            {
                if(op>>i&1)//对二进制位是1的位置进行操作
                {
                    step++;
                    turn(0,i);
                }
            }
            //对于枚举出来的第0行 他是无法全点亮的 所以要枚举0~3行的状态 
            for(int i=0;i<4;i++)
            {
                for(int j=0;j<5;j++)
                {
                    if(g[i][j]=='0')
                    {
                        step++;
                        turn(i+1,j);
                    }
                }
            }
            //检查最后一行是否全部点亮
            bool dark=false;
            for(int i=0;i<5;i++)
            {
                if(g[4][i]=='0')
                {
                    dark=true;
                    break;
                }
            }
            //如果全亮 res存储最小的步数
            if(dark==false) res=min(res,step);
            memcpy(g,backup,sizeof backup);//还原
        }
        if(res>6) res=-1;//这里的res>6包含两个意思 一是真的步数超过了6 二是灯没全亮初始res=10
        cout<<res<<endl;
    }
    return 0;
}
```

## 飞行员兄弟

已知每个把手可以处于以下两种状态之一：打开或关闭。

只有当所有把手都打开时，冰箱才会打开。

把手可以表示为一个 $4×4$ 的矩阵，您可以改变任何一个位置 `[i,j]` 上把手的状态。

但是，这也会使得第 $i$ 行和第 $j$ 列上的所有把手的状态也随着改变。

请你求出打开冰箱所需的切换把手的次数最小值是多少。

### 输入格式

输入一共包含四行，每行包含四个把手的初始状态。

符号 `+` 表示把手处于闭合状态，而符号 `-` 表示把手处于打开状态。

至少一个手柄的初始状态是关闭的。

### 输出格式

第一行输出一个整数 $N$，表示所需的最小切换把手次数。

接下来 $N$ 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。

**注意**：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。

### 数据范围

$1≤i,j≤4$

### 操作

1. 枚举所有方案 0~2^16^-1 二进制表示为16位的二进制数
2. 按照所有方案，对所有灯泡进行操作
3. 判断灯泡是否全亮，全亮的话记录方案。

### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N=5;
char g[N][N],backup[N][N];

int get(int x,int y) 
{
    return x*4+y;
}

void turn_one(int x,int y)
{
    if(g[x][y]=='+') g[x][y]='-';
    else g[x][y]='+';
} 

void turn_all(int x,int y)
{
    for(int i=0;i<4;i++)
    {
        turn_one(x,i);
        turn_one(i,y);
    }
    turn_one(x,y);//上面把点(x,y)切换了两次
}
int main()
{
    for(int i=0;i<4;i++) cin>>g[i];

    vector<PII> res;
    
    //枚举所有方案 op是一维状态
    //用二进制表示2^16种操作开关的方案
    //op代表2^16种方案 而十进制的0~16的二进制数的0和1能表示2^16种不重不漏的开关操作方案
    for(int op=0;op < 1<<16;op++)  
    {
        vector<PII> temp;  //临时存储方案
        memcpy(backup,g,sizeof g);  //备份

        for(int i=0;i<4;i++)
        {
            for(int j=0;j<4;j++)
            {
                if(op>>get(i,j)&1)  //这个位置是1的时候就要操作一下这个位置的开关
                {
                    temp.push_back({i,j});
                    turn_all(i,j);
                }
            }
        }

        //判断所有灯泡的亮灭
        bool dark=false;
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
                if(g[i][j]=='+')
                    dark=true;

        if(dark==false)
        {
            if(res.empty() || res.size()>temp.size()) res=temp;
        }

        memcpy(g,backup,sizeof backup);  //恢复
    }
    
    cout<<res.size()<<endl;
    for(int i=0;i<res.size();i++)
        cout<<res[i].first+1<<' '<<res[i].second+1<<endl;

    return 0;    

}
```

