# 二分

## 机器人跳跃问题

### 问题描述

机器人正在玩一个古老的基于 DOS 的游戏。

游戏中有 $N+1$ 座建筑——从 $0$ 到 $N$ 编号，从左到右排列。

编号为 $0$ 的建筑高度为 $0$ 个单位，编号为 $i$ 的建筑高度为 $H(i)$ 个单位。

起初，机器人在编号为 $0$ 的建筑处。

每一步，它跳到下一个（右边）建筑。

假设机器人在第 $k$个建筑，且它现在的能量值是 $E$，下一步它将跳到第 $k+1$ 个建筑。

如果 $H(k+1)>E$，那么机器人就失去 $H(k+1)−E$ 的能量值，否则它将得到 $E−H(k+1)$ 的能量值。

游戏目标是到达第 $N$ 个建筑，在这个过程中能量值不能为负数个单位。

现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？

### 解题思路

对于初始的 $E$ 满足二段单调性，如果一个 $E$ 满足了在所有跳跃的点的能量都不为 $0$ ，那么大于等于 $E$ 的都能满足，所以我们只需要二分 $E$ ，检查是否能满足非 $0$ 就可以找到最小的 $E$。

根据题意和公式化简可以得出，无论当前能量比下一个建筑的高度多还是少，其能量变化都为 $2*E - h(k+1)$

### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,h[N];
bool cheak(int e)
{
    for(int i=1;i<=n;i++)
    {
        e=2*e-h[i];
        if(e<0) return false;
        if(e>=1e5) return true;//如果e的值大于等于高度的最大值根据上面公式可以得出必然e在今后不会为负数
    }
    return true;
}
int main()
{
    cin>>n;
    
    for(int i=1;i<=n;i++) cin>h[i];
    
    int l=0,r=1e5;
    while(l<r)
    {
        int mid=l+r>>1;
        if(cheak(mid)) r=mid;
        else l=mid+1;
    }
    
    cout<<l;
    return 0;}
```



## 四平方和

### 题目描述

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 $4$ 个正整数的平方和。

如果把 $0$ 包括进去，就正好可以表示为 $4$ 个数的平方和。

比如：

$5=0^2+0^2+1^2+2^2$
$7=1^2+1^2+1^2+2^2$

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 $4$ 个数排序：

$0≤a≤b≤c≤d$

并对所有的可能表示法按 $a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。

数据范围

$0<N<5∗10^6$

### 如何替代三重循环暴力枚举？

把三重循环转化为两个双重循环，分别枚举$c,d$ 和$a,b$，即可降低时间复杂度。

### 如何得到字典序最小的解

因为a和b都是从最小开始枚举的，所以在有解的情况下a和b一定是最小的。所以我们只需确定c和d同时是最小的。为了找到c和d同时是最小的解，我们利用一个结构体来存储c^2^+d^2^,c,d。枚举完c和d后按照c^2^+d^2^,c,d优先级的递增的顺序进行结构体排序。再枚举a和b，利用二分找到四平方和的解，找到的就是最小的解。

### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=3e6+10;
int n,m;
struct Stu
{
    int e,c,d;
}s[N];

bool cmp(const Stu &x,const Stu &y)
{
    if(x.e != y.e) return x.e<y.e;
    if(x.c != y.c) return x.c<y.c;
    return x.d<y.d;
}


int main()
{
    cin>>n;
    
    for(int c=0;c*c<=n;c++)
    {
       for(int d=c;c*c+d*d<=n;d++)
        {
            s[m++]={c*c+d*d,c,d};
        }
    }
    
    sort(s,s+m,cmp);
    
   for(int a=0;a*a<=n;a++)
       for(int b=a;b*b+a*a<=n;b++)
       {
           int t=n-a*a-b*b;
           int l=0,r=m;
           while(l<r)
           {
               int mid=l+r>>1;
               if(s[mid].e>=t) r=mid;
               else l=mid+1;
           }
           if(s[l].e==t)
           {
               cout<<a<<' '<<b<<' '<<s[l].c<<' '<<s[l].d;
               return 0;
           }
       }
    return 0;
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N=2500010;
int n,m;
unordered_map<int,PII> S;

int main()
{
    for(int c=0;c*c<=n;c++)
    {
        for(int d=c;d*d+c*c<=n;d++)
        {
            int t=c*c+d*d;
            if(S.count(t)==0)
            {
                S[t]={c,d};//把c*c+d*d作为key值 利用哈希进行排序存储 
                //因为c和d是从小到大枚举的 所以第一个满足c*c+d*d的字典序就是最小的
            }
        }
    }

    for(int a=0;a*a<=n;a++)
    {
        for(int b=a;a*a+b*b<=n;b++)
        {
            int t=n-a*a-b*b;
            if(S.count(t))
            {
                cout<<a<<' '<<b<<' '<<S[t].first<<' '<<S[t].second;
                return 0;
            }
        }
    }
    return 0;
}
```

## 分巧克力

儿童节那天有 $K$ 位小朋友到小明家做客。

小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 $N$ 块巧克力，其中第 $i$ 块是 $Hi×Wi$ 的方格组成的长方形。

为了公平起见，小明需要从这 $N$ 块巧克力中切出 $K$ 块巧克力分给小朋友们。

切出的巧克力需要满足：

1. 形状是正方形，边长是整数
2. 大小相同

例如一块 $6×5$ 的巧克力可以切出 $6$ 块 $2×2$ 的巧克力或者 $2$ 块 $3×3$ 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

### 解题思路

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/202210221136022.png" style="zoom:50%;" />

由于边长和块数成反比例关系，块数越多边长最小，所以我们利用这个性质，用二分找到大于等于所求块数对应的边长，就是满足题意的最大边长。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n,k;
int w[N],h[N];
bool check(int x)
{
    int res=0;
    for(int i=0;i<n;i++)
    {
        res=res+(w[i]/x)*(h[i]/x);
    }
    if(res<k) return false;
    else return true;
}
int main()
{
    cin>>n>>k;
    
    for(int i=0;i<n;i++)
    {
        cin>>h[i]>>w[i];
    }
    
    int l=1,r=1e5;
    while(l<r)
    {
        int mid=l+r+1>>1;
        if(check(mid)) l=mid;//个数多的时候边长是小的 求边长是最大的 所以l=mid
        else r=mid-1;
    }
    
    cout<<l;
    return 0;
}
```

# 前缀和

## 激光炸弹

坐标数据范围为 $0$~$5000$ ，因为使用前缀和应该从$1$开始，自增之后变为 $1$~$5001$ ,数组应该至少开$5002$ 个。

```c++
#include<bits/stdc++.h>
using namespace std;
int s[5002][5002];

int main()
{
    int q,r;
    cin>>q>>r;

    r=min(r,5001);  //因为地图范围有限,限制炸弹最大半径

    while(q--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        s[x+1][y+1]+=z;   //坐标自增1从1
    }

    for(int i=1;i<=5001;i++)
    {
        for(int j=1;j<=5001;j++)
        {
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//s代替s和节省空间
        }
    }

    int res=0;
    for(int i=1;i<=5001-r+1;i++)
    {
        for(int j=1;j<=5001-r+1;j++)
        {
            int x2=i+r-1,y2=j+r-1;
            res=max(res,s[x2][y2]-s[x2][j-1]-s[i-1][y2]+s[i-1][j-1]);
        }
    }

    cout<<res;
    return 0;
}
```



## K倍区间

输出满足任意区间能整除`K`的区间的个数。

### 数据范围

$1≤N,K≤100000$
$1≤Ai≤100000$

### 解题分析

- 两重循环会超时，问题的本质是，当`R`固定时，在`1~R`之间有多少个`L`满足`s[R]-s[L-1]%K == 0`；
- 也就是，有多少个`s[L-1]`与`s[R]`的余数相同；
- 从 1 开始遍历数组，走到 $i$ ，更新 $s[0]$ 到 $s[i - 1]$ 的余数数组 `cnt`，看有多少个区间和 $s[i]$ 的余数相同，就是有多少个 K 倍区间；
- 数组取值范围为 $[1, n]$，那么 $L-1$ 的取值范围为 $[0,n-1]$，所以需要用到 $s[0]-s[n-1]$，因为 $s[0]$为0，所以需要初始化 $cnt[0]$ 为 $1$。

### AC代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
typedef long long LL;

int n, k;
LL s[N];
int cnt[N];

int main()
{
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        s[i] = s[i - 1] + s[i];
    }
    // s[0] == 0
    cnt[0] = 1;
    LL res = 0;
    for(int i = 1; i <= n; i++)
    {
        res += cnt[s[i] % k];
        cnt[s[i] % k]++;
    }
    
    cout << res;
    return 0;
}
```



## 最大子矩阵

给定一个长度为 $n$ 的整数数组 $a1,a2,…,an$ 和一个长度为 $m$ 的整数数组 $b1,b2,…,bm$。

设 $c$ 是一个 $n×m$ 的矩阵，其中 $ci,j=ai×bj$。

请你找到矩阵 $c$ 的一个子矩阵，要求：该子矩阵所包含的所有元素之和不超过 $x$，并且其面积（包含元素的数量）应尽可能大。

输出满足条件的子矩阵的最大可能面积（即包含元素的最大可能数量）。

#### 输入格式

第一行包含两个整数 $n,m$。

第二行包含 $n$ 个整数 $a1,a2,…,an$。

第三行包含 $m$ 个整数 $b1,b2,…,bm$。

第四行包含一个整数 $x$。

#### 输出格式

一个整数，表示满足条件的子矩阵的最大可能面积（即包含元素的最大可能数量）。

如果不存在满足条件的子矩阵，则输出 $0$。

#### 数据范围

前三个测试点满足 $1≤n,m≤5$。
所有测试点满足 $1≤n,m≤2000$，$1≤ai,bi≤2000$，$1≤x≤2×10^9$。

#### 解题思路

因为 $C[i][j]\ =\ a[i]\ *\ b[j]$ ，通过画图观察，我们可以找到规律，$(x1,y1)到(x2,y2)$ 的区间和等于 $(a[x1]到a[x2]区间和)*(b[y1]到b[y2]的区间和)$。

因为满足最大的面积的矩阵的区间和不大于 $x$ ，再用`s1[i]`和`s2[i]`表示长度为`i`的区间和的最小值。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2010,INF=1e8;
int a[N],b[N];
int s1[N],s2[N];
int n,m;
//因为要使矩形面积最大（元素最多） 那就要保证元素都是最小的 所以就要找到区间和最小的区间
int main()
{
    cin>>n>>m;
    //读入a和b 加预处理a和b的前缀和
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        a[i]+=a[i-1];
    }
    for(int i=1;i<=m;i++)
    {
        cin>>b[i];
        b[i]+=b[i-1];
    }
    //用s1和s2分别存储a和b在第i长度的最小之和
    for(int len=1;len<=n;len++)
    {
        s1[len]=INF;
        for(int i=1;i+len-1<=n;i++)
        {
            int j=i+len-1;
            s1[len]=min(s1[len],a[j]-a[i-1]);
        }
    }

    for(int len=1;len<=m;len++)
    {
        s2[len]=INF;
        for(int i=1;i+len-1<=m;i++)
        {
            int j=i+len-1;
            s2[len]=min(s2[len],b[j]-b[i-1]);
        }
    }

    int x;
    cin>>x;

    int res=0;//存储最大面积
    for(int i=1,j=m;i<=n;i++)
    {
        while(j>0 && s1[i]>x/s2[j]) j--;
        /*
        i代表a数组选取的长度 j代表b数组选取的长度
        因为a数组本身比b数组短
        所以最小长度从a数组开始递增 最大长度从b数组开始递减

        本身i就是当前的最小长度了 如果此时区间和大于x 只能缩短b的选取的长度
        通过枚举得出之和不超x的最大面积
        */
        res=max(res,i*j);
    }

    cout<<res;
    return 0;
}
```

## 统计子矩阵

4405

### 解题思路

如果暴力时间复杂度 $O(n^4)$，优化之后 $O(n^3)$；

### 算法标签

- 前缀和

- 双指针

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 510;
int a[N][N], s[N][N];

int main()
{
    int n, m, k;
    cin >> n >> m >> k;

    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> a[i][j];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            s[i][j] = s[i - 1][j] + s[i][j -1] - s[i - 1][j - 1] + a[i][j];

    long long cnt = 0;

    // i 和 j 枚举左右边界
    for(int i = 1; i <= m; i++)
    {
        for(int j = i; j <= m; j++)
        {
            // t 是上边界, d 是下边界
            // 遍历下边界
            for(int t = 1, d = 1; d <= n; d++)
            {
                int sum = s[d][j] - s[t - 1][j] - s[d][i - 1] + s[t - 1][i - 1];
                // 推进上指针
                // 只要区间和大于 k，向下推进上边界
                while(t <= d && sum > k)
                {
                    t++;
                    // 更新区间和
                    sum = s[d][j] - s[t - 1][j] - s[d][i - 1] + s[t - 1][i - 1];
                }
                // 如果推进完区间合法就加上以下边界为底的区间数
                if(t <= d) cnt += d - t + 1;
            }
        }
    }

    cout << cnt;
    return 0;
}
```

## 壁画

562

### 解题思路

- 题目描述中说：被毁掉的墙段一定只与**一段**还未被毁掉的墙面相邻，说明墙是从两边开始被摧毁的；
- 因为每天先画一段墙再毁掉一段墙，所以最终画好的墙的长度是：$n / 2$ 向上取整，且画好的墙是连续的；
- 有了以上分析，我们可以在墙中遍历每个画好的区间，得到最大的美观度；
- 有一点需要考虑，是否每个区间都能被成功的画出，可采用博弈论证明，每个区间都能画到；

### 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e6 + 10;
int n, s[N];

int main()
{
    int T;
    cin >> T;
    for(int i = 1; i <= T; i++)
    {
        cin >> n;
        string str;
        cin >> str;
        // 取出字符串
        for(int j = 0; j < str.size(); j++)
            s[j + 1] = str[j] - '0';
        // 构造前缀和
        for(int j = 1; j <= n; j++)
            s[j] += s[j - 1];
        // 得到最后画的长度，n / 2 向上取整
        int len = n + 1 >> 1;
        // 遍历 len 区间(博弈论证明每个区间都能画到)
        int res = -1;
        for(int j = len; j <= n; j++)
            res = max(res, s[j] - s[j - len]);
        cout << "Case #" << i << ": " << res << endl;
    }
    return 0;
}

```



# 差分

## 增减序列

![](https://cdn.jsdelivr.net/gh/chousinbin/Image/202303061540582.png)

## 空调

4262

### 解题思路

- 首先计算出期望值与实际值之差，差为正需要升温，否则降温；
- 经过每次给一个区间升降温 1 个单位，使得差值数组为 0 ；
- 由于差值数组是差分数组的前缀和，想要把差值数组归零，就等价于把差分数组归零，此时就把区间操作转为两点操作；
- 差分数组的取值范围是 $[1, n + 1]$，且差分数组之和为 0；
- 想要最小操作次数把差分数组归零，就要在差分数组中分别取一个正和负的点，正的减一，负的加一；
- 那么最小操作次数就等于差分数组中正值之和或负值之和的绝对值；

### 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n;
int p[N], t[N];
int a[N], b[N];

int main()
{
    cin >> n;
    
    for(int i = 1; i <= n; i++) cin >> p[i];
    for(int i = 1; i <= n; i++) cin >> t[i];
    // a 存储温度之差，把差值正的减一，负的加一，差值变成 0
    for(int i = 1; i <= n; i++)
        a[i] = p[i] - t[i];
    // 差分差值
    for(int i = 1; i <= n; i++)
    {
        b[i] += a[i];
        b[i + 1] -= a[i];
    }
    // 想要把差值变为0，就要把差值的差分数组变为 0
    // 因为差分数组之和恒为 0，所以差分数组 b 上正数和负数的之和为 0
    // 想要通过每次差值数组 a 区间加或减 1，
    // 可以在差分数组 b 上任找一个负数的点加 1,正数的点减 1
    // 所以最少得次数就是差分数组上正数或负数之和的绝对值
    // 注意差分数组的取值范围为 [1, n + 1];
    int res = 0;
    for(int i = 1; i <= n + 1; i++)
    {
        if(b[i] > 0) res += b[i];
    }
    cout << res;
    return 0;
}
```

