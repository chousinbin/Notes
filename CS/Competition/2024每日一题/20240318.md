# 借教室

题目描述：https://www.acwing.com/problem/content/505/

## 算法标签

- 二分
- 差分

## 解题思路

阅读了题目，看了算法标签是二分。就想着按订单顺序模拟，判断到某个订单满足不满足教室数量。以为是二分订单日期区间，找到小于租借数量的日期，结果发现日期区间内，剩余教室数量不是有序地，所以无法使用二和找到一个小于租借数量的日期。

正确的做法是二分订单，因为每来一个订单就会导致剩余教室数量减少，从 $1$ - $n$ 号订单教室数量是不断减少的。这样每次二分判断从 $1$ 到 $mid$ 订单每天所需教室数量累加值是否能被满足，判断需要用到差分 $O(n + m)$直到二分出第一个不满足的订单，就是所求答案。

## 代码实现

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int n, m;
int w[N];
int d[N], s[N], t[N];

typedef long long LL;
LL b[N];

bool check(int mid)
{
    memset(b, 0, sizeof b);
    
    for(int i = 1; i <= mid; i++)
    {
        b[s[i]] += d[i];
        b[t[i] + 1] -= d[i];
    }
    
    LL s = 0;
    for(int i = 1; i <= n; i++)
    {
        s += b[i];
        if(s > w[i]) return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++) cin >> w[i];
    for(int i = 1; i <= m; i++) cin >> d[i] >> s[i] >> t[i];
    // 二分订单
    int l = 0, r = m;
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
   
    if(r == m) cout << 0 << endl;
    else cout << -1 << endl << r + 1 << endl;
    
    return 0;
}
```



# 管道

题目描述：https://www.acwing.com/problem/content/5410/

## 算法标签

- 二分
- 区间合并

## 实现思路

- 先理解出来每个阀门打开后向水管两边注水蔓延，不需考虑水从哪边来；
- 此题按时间跨度 $0 - 2e^9$ 从左往右水管中的水是不断蔓延的，有单调性，所以可以按时间二分；
- 二分找到刚好水管被充满的时刻；
- 二分之后，可以根据题目公式和现在二分枚举的时刻算出几个被水充满的区间；
- 要判断这些区间能否覆盖整个水管，可以使用区间合并。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int len, n;
int p[N], s[N], b[N];

typedef long long LL;
typedef pair<int, int> PII;

bool check(int mid)
{
    vector<PII> a, b;
    for(int i = 0; i < n; i++)
    {
        // 此时阀门打开，存储覆盖区间
        if(mid >= s[i])
        {
            int l = max(1, p[i] - (mid - s[i]));
            // 注意爆 int
            int r = min((LL)len, (LL)p[i] + (mid - s[i]));
            a.push_back({l, r});
        }
    }
    //区间合并
    sort(a.begin(), a.end());
    int begin = -1, end = -1;
    for(int i = 0; i < a.size(); i++)
    {
        // 当前区间与下一区间无交集
        // 注意：本题区间相邻就可以合并，与模板有所区别
        if(end + 1 < a[i].first)
        {
            begin = a[i].first;
            end = a[i].second;
        }
        else
        {
            end = max(end, a[i].second);
        }
    }
    return begin == 1 && end == len;
}

int main()
{
    cin >> n >> len;
    for(int i = 0; i < n; i++) cin >> p[i] >> s[i];
    
    int l = 0, r = 2e9;
    while(l < r)
    {
        LL mid = (LL)l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    
    cout << r;
    return 0;
}
```





