# 借教室

题目描述：https://www.acwing.com/problem/content/505/

## 算法标签

- 二分
- 差分

## 解题思路

阅读了题目，看了算法标签是二分。就想着按订单顺序模拟，判断到某个订单满足不满足教室数量。以为是二分订单日期区间，找到小于租借数量的日期，结果发现日期区间内，剩余教室数量不是有序地，所以无法使用二和找到一个小于租借数量的日期。

正确的做法是二分订单，因为每来一个订单就会导致剩余教室数量减少，从 $1$ - $n$ 号订单教室数量是不断减少的。这样每次二分判断从 $1$ 到 $mid$ 订单每天所需教室数量累加值是否能被满足，判断需要用到差分 $O(n + m)$直到二分出第一个不满足的订单，就是所求答案。

## 实现代码

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int n, m;
int w[N];
int d[N], s[N], t[N];

typedef long long LL;
LL b[N];

bool check(int mid)
{
    memset(b, 0, sizeof b);
    
    for(int i = 1; i <= mid; i++)
    {
        b[s[i]] += d[i];
        b[t[i] + 1] -= d[i];
    }
    
    LL s = 0;
    for(int i = 1; i <= n; i++)
    {
        s += b[i];
        if(s > w[i]) return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++) cin >> w[i];
    for(int i = 1; i <= m; i++) cin >> d[i] >> s[i] >> t[i];
    // 二分订单
    int l = 0, r = m;
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
   
    if(r == m) cout << 0 << endl;
    else cout << -1 << endl << r + 1 << endl;
    
    return 0;
}
```



# 管道

题目描述：https://www.acwing.com/problem/content/5410/

## 算法标签

- 二分
- 区间合并

## 解题思路

- 先理解出来每个阀门打开后向水管两边注水蔓延，不需考虑水从哪边来；
- 此题按时间跨度 $0 - 2e^9$ 从左往右水管中的水是不断蔓延的，有单调性，所以可以按时间二分；
- 二分找到刚好水管被充满的时刻；
- 二分之后，可以根据题目公式和现在二分枚举的时刻算出几个被水充满的区间；
- 要判断这些区间能否覆盖整个水管，可以使用区间合并。

## 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int len, n;
int p[N], s[N], b[N];

typedef long long LL;
typedef pair<int, int> PII;

bool check(int mid)
{
    vector<PII> a, b;
    for(int i = 0; i < n; i++)
    {
        // 此时阀门打开，存储覆盖区间
        if(mid >= s[i])
        {
            // 左边界限制为 1
            int l = max(1, p[i] - (mid - s[i]));
            // 注意爆 int
            // 右边界限制为 len
            int r = min((LL)len, (LL)p[i] + (mid - s[i]));
            a.push_back({l, r});
        }
    }
    //区间合并
    sort(a.begin(), a.end());
    int begin = -1, end = -1;
    for(int i = 0; i < a.size(); i++)
    {
        // 当前区间与下一区间无交集
        // 注意：本题区间相邻就可以合并，与模板有所区别
        if(end + 1 < a[i].first)
        {
            begin = a[i].first;
            end = a[i].second;
        }
        else
        {
            end = max(end, a[i].second);
        }
    }
    return begin == 1 && end == len;
}

int main()
{
    cin >> n >> len;
    for(int i = 0; i < n; i++) cin >> p[i] >> s[i];
    
    int l = 0, r = 2e9;
    while(l < r)
    {
        LL mid = (LL)l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    
    cout << r;
    return 0;
}
```

# 钓鱼

> 喜欢钓鱼。

## 题目描述

[AcWing 5344](https://www.acwing.com/problem/content/1264/)

## 算法标签

- 多路归并
- 贪心

## 解题思路

1. 在鱼塘间移动不能回头，**回头就是在浪费时间**，因为在每个鱼塘钓的数量只有在此鱼塘钓的总时长有关，与时机无关；
2. 总时长 = 钓鱼时长 + 走路时长，枚举都在哪几个鱼塘钓能钓得多：$1 - m \in n$，在每个鱼塘钓多久；
3. 再算从这几个鱼塘中，每个鱼塘钓多少次鱼获最多，这句需要多路归并；
4. 即使多路归并中是在鱼塘中来回切换的，多路归并得到的是一个最优方案，实际垂钓中记住方案就可以**不回头**得到最大鱼获。

## 实现代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110;

int a[N], b[N], c[N];
int spend[N]; // 标记第 i 个鱼塘已经钓了几次

// 求当前 x 号鱼塘，下一杆能钓获多少鱼
int get(int x)
{
    return max(0, a[x] - b[x] * spend[x]);
}

// 求在 1 - n 个鱼塘，钓 t 次的总鱼获
// 函数内是不考虑切换鱼塘的时间成本
// 找到固定时间内，每个鱼塘钓几次总鱼获最多，得到最优方案
// 而实际过程，可以根据最优方案，充分垂钓完每个鱼塘，一次性走到 n 号鱼塘
int fish(int n, int t)
{
    int res = 0;
    memset(spend, 0, sizeof spend);
    
    // debug
    // t 有可能是负值，单纯 t-- 不加上整数限定，导致 TLE
    // 所以 for 更安全，保证参数
    while(t > 0 && t--)
    {
        // 表示当前几个鱼塘中，下一杆钓的最多的鱼塘的下标
        int p = 1;
        for(int i = 2; i <= n; i++)
            if(get(p) < get(i))
                p = i;
        // 加上这一鱼塘这一杆的鱼获        
        res += get(p);
        // 这个鱼塘所钓的次数加一
        spend[p]++;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;

    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) cin >> b[i];
    for(int i = 2; i <= n; i++)
    {
        cin >> c[i];
        // 顺便前缀和，c[i] 表示第 1 到 i 鱼塘所需路程时间之和
        c[i] += c[i - 1];
    }
    int t;
    cin >> t;
    
    // 枚举在 1 到 i 鱼塘之间垂钓
    int res = 0;
    for(int i = 1; i <= n; i++)
        res = max(res, fish(i, t - c[i]));
        
    cout << res;
    return 0;
}
```

# 技能升级

## 题目描述



## 算法标签

- 多路归并
- 贪心
- 二分

## 解题思路

1. 二分出一个最大的数值 x ，使得原数列中 >= x 的个数 >= M 个，这样 x 就是第 M 个数的数值；
2. 求每个技能中 >= x 的个数利用倒序等差数列特性得到公式：$\left \lfloor \frac {a[i] - x}{b[i]} \right \rfloor + 1$
3. 当找到 x，根据每个技能的最大值、差、x（最小值）、个数求得每个技能攻击力之和；
4. 汇总之后，减去多余 M 个 x 的值，即为所求。因为原数组中，大于等于 x 的个数多余 M 个。

## 实现代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
typedef long long LL;

int n, m;
int a[N], b[N];

bool check(int mid)
{
    LL res = 0;
    for(int i = 1; i <= n; i++)
        if(a[i] >= mid)
            res += (a[i] - mid) / b[i] + 1;
    return res >= m;
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i] >> b[i];
    
    // 二分第 M 的数的数值
    int l = 0, r = 1e6;
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    
    // 计算技能攻击力之和
    LL res = 0, cnt = 0;
    for(int i = 1; i <= n; i++)
    {
        
        if(a[i] >= r)
        {
            // 单个技能满足的级数
            int c = (a[i] - r) / b[i] + 1;
            // 这个技能满足 >= r 的最小值
            int end = a[i] - (c - 1) * b[i];
            
            cnt += c;
            res += (LL) (a[i] + end) * c / 2;
        }
    }
    
    cout << res - (cnt - m) * r;
    return 0;
}
```

