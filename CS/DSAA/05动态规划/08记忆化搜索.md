# 05x08记忆化搜索



## 滑雪

给定一个 $R$行 $C$列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 $i$行第 $j$列的点表示滑雪场的第 $i$行第 $j$列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 $24−17−2−1$。

在给定矩阵中，最长的滑行轨迹为 $25−24−23−…−3−2−1$，沿途共经过 $25$个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

#### 输入格式

第一行包含两个整数 $R$和 $C$。

接下来 $R$行，每行包含 $C$个整数，表示完整的二维矩阵。

#### 输出格式

输出一个整数，表示**可完成的最长滑雪长度**。

#### 数据范围

$1≤R,C≤300$
$0≤矩阵中整数≤10000$

#### 输入样例：

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

#### 输出样例：

```
25
```



### 解题思路

#### 状态表示

`f[i][j]`：所有从`[i][j]`开始滑的最长路径。

#### 状态表示

从当前点如果可以向上下左右滑的情况下。因为只能从高往低走，所以图一定不会存在环，是一个拓扑图。

`f[i][j]=1+max(f[i-1][j],f[i+1][j],f[i][j-1],f[i][j+1])`



```c++
#include<bits/stdc++.h>
using namespace std;
const int N=310;

int n,m;
int h[N][N];
int f[N][N];  //记忆化数组
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};

int dfs(int x,int y)
{
    if(f[x][y]!=-1) return f[x][y];  //这个点如果被算过，直接c返回
    
    f[x][y]=1;  //默认自己这一格为1
    for(int i=0;i<4;i++)
    {
        int a=dx[i]+x,b=dy[i]+y;
        if(a>=1 && a<=n && b>=1 && b<=m && h[x][y]>h[a][b])
            f[x][y]=max(f[x][y],dfs(a,b)+1);  //dfs递归到结尾 从结尾回退
    }
    
    return f[x][y];
}

int main()
{
    cin>>n>>m;
    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>h[i][j];
    
    memset(f,-1,sizeof f);  //初始化f
    
    int res=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            res=max(res,dfs(i,j));  //使用递归
    
    cout<<res;
    return 0;
}
```



在记忆化搜索的代码中，起到关键作用的是记忆化数组`f[i][j]`。

如果只是采用 `dfs `暴搜的话，每次在一个位置搜索完之后，状态都不会被保留，下次 `dfs `还是重新开始，就会有很多被算过的位置再重新计算。数据量大就会超时。

记忆化搜索就是 `dfs `+ 记忆化数组`f[i][j]`，在算某一个位置时把它的所有路径上 所有算过的位置状态保存在数组`f[i][j]`里。

`if (f[x][y] != -1) return f[x][y];`，下次求某个被算过的位置的状态时，无需重新计算，直接返回。

数组`f[i][j]`起到了记忆的作用。这里面也体现了空间换时间的思想。



