# 05x06 状态压缩DP



## 蒙德里安的梦想

求把 $N×M$ 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

例如当 $N=2，M=4 $ 时，共有 $5$ 种方案。当 $N=2，M=3$ 时，共有 $3$ 种方案。

如下图所示：

![2411_1.jpg](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

#### 输入格式

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 $N$ 和 $M$。

当输入用例 $N=0，M=0$ 时，表示输入终止，且该用例无需处理。

#### 输出格式

每个测试用例输出一个结果，每个结果占一行。

#### 数据范围

$1≤N,M≤11$

#### 输入样例：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

#### 输出样例：

```
1
0
1
2
3
5
144
51205
```



### 解题思路

#### 核心：

先放横方块，再放竖方块。

#### 规律：

一种方案的横方块摆完剩下竖方块也就一种摆法，横方块的合法方案数，就是总方案数。

#### 判断横方块摆法是否合法：

我们摆完横方块后，能仅用竖方块，填满整个空间。

如何判断所有空余的位置能否填充满竖方块？

可以按列来看，每一列内部所有连续的空闲小格子必须是偶数个。因为竖方块长度为 $2$ 。



#### 状态表示：

`f[i][j]`表示已经将前`i-1`列摆好，且从第`i-1`列伸出到第`i`列的状态是`j`的所有方案数。

`j`用二进制数的01表示`i-1`到 `i`列中每行是否有横方块。

`k`用二进制数的01表示`i-2`到 `i-1`列中每行是否有横方块。

#### 状态计算：

当状态从`f[i-1][k]`转移到`f[i][j]`就要满足：

1. ```
   (j&k)==0
   ```

2. 所有连续空闲的位置的长度必须是偶数

把所有 $2^n$ 个`k`，满足以上条件的`f[i-1][k]`加起来就等于`f[i][j]`。

最终结果是`f[m][0]`前`m-1`列已经摆好，没有伸出来到`m`列的，就是最终答案。

#### 朴素写法 1000ms

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=12,M=1<<N;  //1<<x == 2^x
typedef long long LL;

int n,m;
LL f[N][M];
bool st[M]; //预处理连续的0是否为偶数个

int main()
{
    while(cin>>n>>m,n||m)
    {
        for(int i=0;i< 1<<n;i++)  //预处理2^n个排列
        {
            st[i]=true;
            int cnt=0;  //存储0的个数
            for(int j=0;j<n;j++)  //按行遍历
            {
                if(i>>j&1)  //当前位是1
                {
                    if(cnt%2)  //0为奇数个
                    {
                        st[i]=false;
                        break;
                    }
                    cnt=0;
                }
                else  //当前为0
                	cnt++;
            }
            if(cnt%2) st[i]=false;  //别忘记最后连续的0
        }
        
        memset(f,0,sizeof f);  //多组测试数据 记得初始化
        f[0][0]=1;  //0列是开头 没有从-1延伸到0列的横方块 第一列都是竖方块 此状态为1种
        
        for(int i=1;i<=m;i++) //枚举每一列
            for(int j=0;j< 1<<n;j++)  //枚举i列每一种状态
                for(int k=0;k< 1<<n;k++)  //枚举i-1列每一种状态
                    if((j&k)==0 && st[j|k])  //满足条件
                        f[i][j]+=f[i-1][k];  //f[i-1][k]转移到f[i][j]
        
        cout<<f[m][0]<<endl;  //最终结果：前m-1列方案数已经确定，从m-1伸出到m列的状态是0的方案
    }
    return 0;
}
```



#### 去除无效状态的写法 230ms

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=12,M=1<<N;

typedef long long LL;
LL f[N][M];
int n,m;
bool st[M];
vector<int> state[M];  //预处理存储所有能转移到当前状态的合法状态

int main()
{
    while(cin>>n>>m,n||m)
    {
        for(int i=0;i<1<<n;i++)
        {
            st[i]=true;
            int cnt=0;
            for(int j=0;j<n;j++)
            {
                if(i>>j&1)
                {
                    if(cnt%2)
                    {
                        st[i]=false;
                        break;
                    }
                    cnt=0;
                }
                else
               		cnt++;
            }
            if(cnt%2) st[i]=false;
        }
        
        for(int i=0;i<1<<n;i++)  //当前状态
        {
            state[i].clear();  //多组测试数据当前组先清空
            for(int j=0;j<1<<n;j++)  //前一状态
                if((i&j)==0 && st[i|j])  //所有j能转移到i的合法状态
                    state[i].push_back(j);
        }
        
        memset(f,0,sizeof f);
        f[0][0]=1;
        
        for(int i=1;i<=m;i++)
        	for(int j=0;j<1<<n;j++)
                for(int k=0;k<state[j].size();k++)
                    f[i][j]+=f[i-1][state[j][k]];
        
        cout<<f[m][0]<<endl;
    }
    return 0;
}
```





## 最短Hamilton路径

给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。

Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。

#### 输入格式

第一行输入整数 $n$。

接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到$ j$ 的距离（记为 $a[i,j]$）。

对于任意的 $x,y,z$，数据保证 $a[x,x]=0$，$a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。

#### 输出格式

输出一个整数，表示最短 Hamilton 路径的长度。

#### 数据范围

$1≤n≤20\\0≤a[i,j]≤10^7$

#### 输入样例：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

#### 输出样例：

```
18
```



### 解题思路

1. 考虑哪些点被用过
2. 考虑当前停止在哪个点上

#### 时间复杂度

朴素做法 $(n-2)!*n$

优化算法 $2^{20}*20*20=2*10^7$

#### 状态表示

`f[i][j]`:所有从`0`走到`j`,走过的点是`i`这种二进制`01`状态的最小路径。

#### 状态计算

`f[i][j]=min(f[i减去j点的状态][k]+a[k][j])` k是倒数第二个点的情况

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=20,M=1<<N;

int a[N][N];
int n;
int f[M][N];

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j];
    
    memset(f,0x3f,sizeof f);
    f[1][0]=0;  //0到0起点为0
    
    for(int i=0;i<1<<n;i++)  //m
        for(int j=0;j<n;j++)  //从右往前数
           if(i>>j&1)  //i情况里面包含j 才能走到j
               for(int k=0;k<n;k++)
                   if((i-(1<<j)) >> k &1)  //先把j之后的状态删除 再找能用的k
                       f[i][j]=min(f[i][j],f[i-(1<<j)][k]+a[k][j]);
    
    cout<<f[(1<<n)-1][n-1];  //2^n - 1 的二进制数正好是n个1 题目要求走遍所有点
    return 0;
}
```

#### i-(1<<j)  >> k & 1 ?

我的理解是把二进制位上从`j`一直到结尾都抹去，也就是把`j`朝后状态都删除，从前边找`k`。具体还未能证明。

 $当i=36=(100100)时，此时j可以取2，1<<j=2^2=4=(000100)$

$i-(1<<j)=36-4=(100100)-(000100)=32=(100000)$ 

由此可见，经过`i-(1<<j)`，状态`i`的`j`（包含）之后的二进制位都变为了`0`，这样就使之后的位无效，确保`k`在状态`i`的`0`-`j-1`之间。
