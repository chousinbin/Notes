# 二分图

二分图的顶点可以分成两个互斥的独立集 U 和 V 的图，使得所有边都是连结一个 U 中的点和一个 V 中的点。顶点集 U、V 被称为是图的两个部分。等价的，二分图可以被定义成图中所有的环都有偶数个顶点。

二分图 $\iff$ 图中不含奇数环（环中边的数量为奇数）

# 染色法判定二分图

### 时间复杂度

$O(n + m)$

### 实现思路

- 邻接表存储图
- DFS 递归染色

### 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, M = 2e5 + 10;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

// 递归染色
bool dfs(int u, int c)
{
    color[u] = c;
    
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        
        if(!color[j])
        {
            if(!dfs(j, 3 - c)) // 染色失败
                return false;
        }
        else if(color[j] == c) // 当前二分图矛盾
            return false;
    }
    
    return true;
}

bool bin()
{
    // for 循环可以包含连通图和非连通图两种情况
    for(int i = 1; i <= n; i++)
        if(!color[i])
            if(!dfs(i, 1))
                return false;
                
    return true;
}

int main()
{
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    
    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    
    bool res = bin();
    
    if(res) puts("Yes");
    else puts("No");
    
    return 0;
}
    
```

# 匈牙利算法

### 时间复杂度

$O(mn)$