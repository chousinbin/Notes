# 拓扑排序

> 有向图才能拓扑排序

**拓扑序列**：对于图中的每条边 $(x, y)$，$x < y$ 。

- 有向
- 无环
- 入度：前驱的个数，入度为 0 的点排在序列的前边
- 出度：后继的个数，出度为 0 的点排在序列的后边

图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。

## 有向图的拓扑序列

### 题目描述

给定一个 𝑛 个点 𝑚 条边的有向图，点的编号是 1 到 𝑛，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。

若一个由图中所有点构成的序列 𝐴 满足：对于图中的每条边 (𝑥,𝑦)，x𝑥 在 𝐴 中都出现在 𝑦 之前，则称 𝐴 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 𝑛 和 𝑚。

接下来 𝑚 行，每行包含两个整数 𝑥 和 𝑦，表示存在一条从点 𝑥 到点 𝑦 的有向边 (𝑥,𝑦)。

#### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 −1。

#### 数据范围

$1≤n,m≤10^5$

### 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, m;
int h[N], e[N], ne[N], idx;
int q[N], d[N];

// 邻接表存图
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topsort()
{
    int hh = 0, tt = -1;
    
    // 入度为 0 的点入队
    for(int i = 1; i <= n; i++)
        if(d[i] == 0) q[++tt] = i;
    
    while(hh <= tt)
    {
        int tmp = q[hh++];
        // 遍历 0 入度的点的后继
        for(int i = h[tmp]; i != -1; i = ne[i])
        {
            // 入度为 0 的点与后继点撤销关系
            int j = e[i];
            d[j]--;
            // 当前点的所有前驱都以入队，无前驱了，当前点也入队
            if(d[j] == 0) q[++tt] = j;
        }
    }
    // 所有都入队说明是拓扑排序
    return tt == n - 1;
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    
    for(int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;
    }
    
    if(topsort()) for(int i = 0; i < n; i++) cout << q[i] << ' ';
    else cout << -1 << endl;
    
    return 0;
}
```



