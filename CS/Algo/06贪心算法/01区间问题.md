**贪心算法**（英语：greedy algorithm），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。

<img src="https://cdn.jsdelivr.net/gh/chousinbin/Image/202401290028387.png" style="zoom: 33%;" />

贪心算法没有常规的套路。大部分题目都是找规律，再证明。证明较难。

# 06x01 区间问题

## 区间选点

给定 $N$ 个闭区间 $[ai,bi]$，请你在数轴上**选择尽量少的点，使得每个区间内至少包含一个选出的点。**

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

#### 输入格式

第一行包含整数 $N$，表示区间数。

接下来 $N$ 行，每行包含两个整数 $ai,bi$，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需的点的最小数量。

#### 数据范围

$1≤N≤10^5$
$−10^9≤ai≤bi≤10^9$

### 解题思路

1. 把所有区间按右端点升序排序
2. 依次枚举每一个区间。如果当前区间中已经包含点，则 $continue$。否则，把点更新为当前区间的右端点。

#### ~~证明？~~

~~我们令最优解为`ans`，某个解为`cnt`。~~
~~`ans`是一个定值、常数，表示最优解的值， 而`cnt`它是一个变量，代表某一种方案的值。~~

~~①证明`ans<=cnt`：上述算法必然能使一个点至少覆盖一个区间，所以`ans<=cnt`。~~

~~②证明`ans>=cnt`：当全部区间两两不相交时，`cnt`必然取到最大值。（在一个区间包含了两个点）。这样在其中一种取到最大值的方案中，`ans>=cnt`，那么剩下的方案中必然`cnt<=`~~

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
typedef pair<int,int> PII;
PII a[N];
int n;

bool cmp(PII a,PII b)
{
    return a.second<b.second;
}

int main()
{
	cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i].first>>a[i].second;
    
    sort(a,a+n,cmp);
    
    int t=-1e9-10,cnt=0;
    for(int i=0;i<n;i++)
    {
        if(t<a[i].first) t=a[i].second,cnt++;
    }
    
	cout<<cnt;
    return 0;
}
```

## 最大不相交区间数量(影院安排节目问题)

给定 $N$ 个闭区间$ [ai,bi]$，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

#### 输入格式

第一行包含整数 $N$，表示区间数。

接下来 $N$ 行，每行包含两个整数$ ai,bi$，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示可选取区间的最大数量。

#### 数据范围

$1≤N≤10^5$
$−10^9≤ai≤bi≤10^9$

### 解题思路

1. 把所有区间按右端点升序排序
2. 依次枚举每一个区间。如果当前区间中已经包含点，则 $continue$。否则，把点更新为当前区间的右端点。

#### 为什么最少的点的数量等于最大不相交区间的数量?

如果几个区间能同时覆盖同一个点，说明这几个区间相交了，所以只能从这几个区间里选出一个。所以有几个最少的点就有多少个最大不相交的区间，问题本质相同。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
typedef pair<int,int> PII;
PII a[N];
int n;

bool cmp(PII a,PII b)
{
    return a.second<b.second;
}

int main()
{
	cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i].first>>a[i].second;
    
    sort(a,a+n,cmp);
    
    int t=-1e9-10,cnt=0;
    for(int i=0;i<n;i++)
    {
        if(t<a[i].first) t=a[i].second,cnt++;
    }
    
	cout<<cnt;
    return 0;
}
```

## 区间分组

给定 $N$ 个闭区间 $[ai,bi]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

#### 输入格式

第一行包含整数 $N$，表示区间数。

接下来 $N$ 行，每行包含两个整数 $ai,bi$，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示最小组数。

#### 数据范围

$1≤N≤10^5$
$−10^9≤ai≤bi≤10^9$



