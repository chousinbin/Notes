# 05x07树形DP



## 没有上司的舞会

Ural 大学有 $N$ 名职员，编号为 $1∼N$。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 $Hi$ 给出，其中 $1≤i≤N$。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

#### 输入格式

第一行一个整数 $N$。

接下来 $N$ 行，第 $i$ 行表示 $i$ 号职员的快乐指数 $Hi$。

接下来 $N−1$ 行，每行输入一对整数$ L,K$，表示 $K$ 是 $L$ 的直接上司。

#### 输出格式

输出最大的快乐指数。

#### 数据范围

$1≤N≤6000,$
$−128≤Hi≤127$

#### 输入样例：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

#### 输出样例：

```
5
```



### 解题思路

![image-20220705163943208](https://cdn.jsdelivr.net/gh/chousinbin/Image/202401290032662.png)

#### 状态表示

`f[u][0]`所有从以`u`为根的子树中选择，并且不选`u`这个结点的方案

`f[u][1]`所有从以`u`为根的子树中选择，并且选则`u`这个结点的方案

属性`Max`

#### 状态计算

`f[u][0]`=$\sum\ max(f[s_i][0],f[s_i][1])$ 
当不包含父结点时，子结点可以选也可以不选，所以取每个子结点选或不选的最大值之和。

`f[u][1]`=$\sum\ f[s_i][0]$
当包含父结点时，子结点不能选择，所以取每个子结点不选的值之和。

#### 时间复杂度

$O(n)$



```c++
#include<bits/stdc++.h>
using namespace std;
const int N=6010;

int n;
int happy[N];  //存储高兴度
int h[N],e[N],ne[N],idx;
int f[N][2];
bool fa[N];  //谁有父结点

//e[idx]存储当前图编号的结点的根编号
//ne[idx]存储下一个子结点的图编号
//h[u]存储u的子结点的头结点的图编号
// 2022年7月5日 邻接表t
void add(int a,int b)  //插入一条边
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u)
{
    f[u][1]=happy[u];
    
    for(int i=h[u];i!=-1;i=ne[i])  //i存储u所有子节点的图编号
    {
        int j=e[i];  //j存储u当前的子节点的根编号
        dfs(j);  //递归到最底层
        
        f[u][1]+=f[j][0];
        f[u][0]+=max(f[j][0],f[j][1]);
    }
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>happy[i];
    
    memset(h,-1,sizeof h);  //初始化根结点
    
    for(int i=0;i<n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        fa[a]=true;  //a有父结点
        add(b,a);  //b时a的上司
    }
    
    int root=1;
    while(fa[root]) root++;  //root存储父结点的编号
    
    dfs(root);
    
    cout<<max(f[root][0],f[root][1]);
    return 0;
}
```



