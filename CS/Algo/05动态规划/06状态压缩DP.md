# 05x06 状态压缩DP

## 蒙德里安的梦想

求把 $N×M$ 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

例如当 $N=2，M=4 $ 时，共有 $5$ 种方案。当 $N=2，M=3$ 时，共有 $3$ 种方案。

如下图所示：

![2411_1.jpg](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

#### 输入格式

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 $N$ 和 $M$。

当输入用例 $N=0，M=0$ 时，表示输入终止，且该用例无需处理。

#### 输出格式

每个测试用例输出一个结果，每个结果占一行。

#### 数据范围

$1≤N,M≤11$

#### 输入样例：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

#### 输出样例：

```
1
0
1
2
3
5
144
51205
```

### 解题思路

#### 核心：

先放横方块，再放竖方块。

#### 规律：

一种方案的横方块摆完剩下竖方块也就一种摆法，横方块的合法方案数，就是总方案数。

#### 判断横方块摆法是否合法：

我们摆完横方块后，能仅用竖方块，填满整个空间。

如何判断所有空余的位置能否填充满竖方块？

可以按列来看，每一列内部所有连续的空闲小格子必须是偶数个。因为竖方块长度为 $2$ 。

#### 状态表示：

`f[i][j]`表示已经将前`i-1`列摆好，且从第`i-1`列伸出到第`i`列的状态是`j`的所有方案数。

`j`用二进制数的01表示`i-1`到 `i`列中每行是否有横方块。

`k`用二进制数的01表示`i-2`到 `i-1`列中每行是否有横方块。

#### 状态计算：

当状态从`f[i-1][k]`转移到`f[i][j]`就要满足：

1. ```
   (j&k)==0
   ```

2. 所有连续空闲的位置的长度必须是偶数

把所有 $2^n$ 个`k`，满足以上条件的`f[i-1][k]`加起来就等于`f[i][j]`。

最终结果是`f[m][0]`前`m-1`列已经摆好，没有伸出来到`m`列的，就是最终答案。

#### 朴素写法 1000ms

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=12,M=1<<N;  //1<<x == 2^x
typedef long long LL;

int n,m;
LL f[N][M];
bool st[M]; //预处理连续的0是否为偶数个

int main()
{
    while(cin>>n>>m,n||m)
    {
        for(int i=0;i< 1<<n;i++)  //预处理2^n个排列
        {
            st[i]=true;
            int cnt=0;  //存储0的个数
            for(int j=0;j<n;j++)  //按行遍历
            {
                if(i>>j&1)  //当前位是1
                {
                    if(cnt%2)  //0为奇数个
                    {
                        st[i]=false;
                        break;
                    }
                    cnt=0;
                }
                else  //当前为0
                	cnt++;
            }
            if(cnt%2) st[i]=false;  //别忘记最后连续的0
        }
        
        memset(f,0,sizeof f);  //多组测试数据 记得初始化
        f[0][0]=1;  //0列是开头 没有从-1延伸到0列的横方块 第一列都是竖方块 此状态为1种
        
        for(int i=1;i<=m;i++) //枚举每一列
            for(int j=0;j< 1<<n;j++)  //枚举i列每一种状态
                for(int k=0;k< 1<<n;k++)  //枚举i-1列每一种状态
                    if((j&k)==0 && st[j|k])  //满足条件
                        f[i][j]+=f[i-1][k];  //f[i-1][k]转移到f[i][j]
        
        cout<<f[m][0]<<endl;  //最终结果：前m-1列方案数已经确定，从m-1伸出到m列的状态是0的方案
    }
    return 0;
}
```

#### 去除无效状态的写法 230ms

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=12,M=1<<N;

typedef long long LL;
LL f[N][M];
int n,m;
bool st[M];
vector<int> state[M];  //预处理存储所有能转移到当前状态的合法状态

int main()
{
    while(cin>>n>>m,n||m)
    {
        for(int i=0;i<1<<n;i++)
        {
            st[i]=true;
            int cnt=0;
            for(int j=0;j<n;j++)
            {
                if(i>>j&1)
                {
                    if(cnt%2)
                    {
                        st[i]=false;
                        break;
                    }
                    cnt=0;
                }
                else
               		cnt++;
            }
            if(cnt%2) st[i]=false;
        }
        
        for(int i=0;i<1<<n;i++)  //当前状态
        {
            state[i].clear();  //多组测试数据当前组先清空
            for(int j=0;j<1<<n;j++)  //前一状态
                if((i&j)==0 && st[i|j])  //所有j能转移到i的合法状态
                    state[i].push_back(j);
        }
        
        memset(f,0,sizeof f);
        f[0][0]=1;
        
        for(int i=1;i<=m;i++)
        	for(int j=0;j<1<<n;j++)
                for(int k=0;k<state[j].size();k++)
                    f[i][j]+=f[i-1][state[j][k]];
        
        cout<<f[m][0]<<endl;
    }
    return 0;
}
```

## 最短Hamilton路径

给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。

Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。

#### 输入格式

第一行输入整数 $n$。

接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到$ j$ 的距离（记为 $a[i,j]$）。

对于任意的 $x,y,z$，数据保证 $a[x,x]=0$，$a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。

#### 输出格式

输出一个整数，表示最短 Hamilton 路径的长度。

#### 数据范围

$1≤n≤20\\0≤a[i,j]≤10^7$

#### 输入样例：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

#### 输出样例：

```
18
```

### 解题思路

1. 考虑哪些点被用过
2. 考虑当前停止在哪个点上

#### 时间复杂度

朴素做法 $(n-2)!*n$

优化算法 $2^{20}*20*20=2*10^7$

#### 状态表示

`f[i][j]`:所有从`0`走到`j`,走过的点是`i`这种二进制`01`状态的最小路径。

#### 状态计算

`f[i][j]=min(f[i减去j点的状态][k]+a[k][j])` k是倒数第二个点的情况

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=20,M=1<<N;

int a[N][N];
int n;
int f[M][N];

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j];
    
    memset(f,0x3f,sizeof f);
    f[1][0]=0;  //0到0起点为0
    
    for(int i=0;i<1<<n;i++)  //m
        for(int j=0;j<n;j++)  //从右往前数
           if(i>>j&1)  //i情况里面包含j 才能走到j
               for(int k=0;k<n;k++)
                   if((i-(1<<j)) >> k &1)  //先把j之后的状态删除 再找能用的k
                       f[i][j]=min(f[i][j],f[i-(1<<j)][k]+a[k][j]);
    
    cout<<f[(1<<n)-1][n-1];  //2^n - 1 的二进制数正好是n个1 题目要求走遍所有点
    return 0;
}
```

#### i-(1<<j)  >> k & 1 ?

我的理解是把二进制位上从`j`一直到结尾都抹去，也就是把`j`朝后状态都删除，从前边找`k`。具体还未能证明。

 $当i=36=(100100)时，此时j可以取2，1<<j=2^2=4=(000100)$

$i-(1<<j)=36-4=(100100)-(000100)=32=(100000)$ 

由此可见，经过`i-(1<<j)`，状态`i`的`j`（包含）之后的二进制位都变为了`0`，这样就使之后的位无效，确保`k`在状态`i`的`0`-`j-1`之间。

## 地宫取宝

X 国王有一个地宫宝库，是 $n×m$ 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

#### 输入格式

第一行 $3$ 个整数，$n,m,k$，含义见题目描述。

接下来 $n$ 行，每行有 $m$ 个整数 $Ci$ 用来描述宝库矩阵每个格子的宝贝价值。

#### 输出格式

输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。

该数字可能很大，输出它对 $1000000007$ 取模的结果。

#### 数据范围

$1≤n,m≤50$,
$1≤k≤12$,
$0≤Ci≤12$

### 解题思路

#### 状态表示 

$f[i][j][k][c]$。集合：所有从起点走到 $(i,j)$ ，并且取了 $k$ 件物品，且最后一件物品的价值是 $c$ 的合法方案的集合。属性：数量。

#### 状态计算

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=55,mod=1000000007;
int n,m,k;
int w[N][N];
int f[N][N][13][14];

int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>w[i][j];
            w[i][j]++;  //物品价值的取值范围是0~12 我们手动改成1~13 把0作为一个边界点
        }
    }    
        
    //第一个选或不选都算是一种方案
    f[1][1][1][w[1][1]]=1;
    f[1][1][0][0]=1;
    
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i==1 && j==1) continue;
            for(int u=0;u<=k;u++)
            {
                for(int v=0;v<=13;v++)
                {
                 
                    //不取
                    f[i][j][u][v]=(f[i][j][u][v]+f[i][j-1][u][v])%mod;
                    f[i][j][u][v]=(f[i][j][u][v]+f[i-1][j][u][v])%mod;
                    //取
				    if(u>0 && v==w[i][j])  //u为0的意思就是一个都不取  当满足c=w[i][j]的时候才能取 因为要取的数是当前最大的
                    {
                        for(int c=0;c<v;c++)
                        {
                            f[i][j][u][v]=(f[i][j][u][v]+f[i-1][j][u-1][c])%mod;
                            f[i][j][u][v]=(f[i][j][u][v]+f[i][j-1][u-1][c])%mod;
                        }
                  	}
                }
            }
        }
    }

    int res=0;
    for(int i=0;i<=13;i++)  //把每种结果都累加一下
    {
        res=(res+f[n][m][k][i])%mod;
    }
    cout<<res;

    return 0;
}
```

## 波动数列

### 解法

$a_n=a_{n-1}+d_i$ ，$d=a或-b$ 。那么数列就是，$x,x+d_1,x+d_1+d_2,x+d_1+d_2+d_3,...,+x+d_1+d_2+...+d_{n-1}$，整理得，$nx+(n-1)d_1+(n-2)d_2+...+d_{n-1}=s$。

再转化，$x=\frac {s-((n-1)d_1+(n-2)d_2+...+d_{n-1})}{n}$。

因为 $x$ 是整数，所以 $s\ mod\ n$ 与 $(s-((n-1)d_1+(n-2)d_2+...+d_{n-1}))\ mod\ n$ 相等。

### 状态表示

`f[i][j]`所有只考虑前 $i$ 项，且当前的数列之和 % $n$ 是 $j$ 的方案的数量。

### 状态计算

第 $i$ 次选择的时候第 $i$ 个数可以选择加 $a$ 或减 $b$ 。

如果选加 $a$，那么前 $i$ 个数的和为：$[(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}+(n−i)a]$

再计算，$[(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}+(n−i)a]\ \%\ n\ ≡\ j\ \%\ n$。

转化后，$(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}\ ≡\ j−(n−i)a$。

所以，$f[i][j]\ =\ f[i-1][j-(n-i)*a\ \%\ n]$ 。

同理选减$b$,$f[i][j]\ =\ f[i-1][j+(n-i)*b\ \%\ n]$ 。

综上状态计算最终表达式：$f[i][j]=f[i-1][j-(n-i)*a\ \%\ n]\ +\ f[i-1][j+(n-i)*b\ \%\ n]$

##### 最后$f[n-1][get\_mod(n,s)]$的解释。

序列的长度是 $n$，若当前第一个数是$x$，需要组合 $n - 1$个数，才变成$S$，所以相当于求从前$n - 1$个项中选，余数是 $s\ \%\ n$的方案数。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010,mod=100000007;
int dp[N][N];
int get_mod(int a,int b)
{
    return (a%b+b) % b;
}
int main()
{
    int n,s,a,b;
    cin>>n>>s>>a>>b;

    dp[0][0]=1;

    for(int i=1;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            dp[i][j]=(dp[i-1][get_mod(j-a*(n-i),n)] + dp[i-1][get_mod(j+b*(n-i),n)]) % mod;
        }
    }

    cout<<dp[n-1][get_mod(s,n)];
    return 0;
}
```

