# 05x05数位统计DP

当我们求一个区间性的问题的时候，如果计算量太大，我们可以采取`前缀和思想`，优化时间复杂度。

## 计数问题

给定两个整数 $a$ 和 $b$，求 $a$ 和 $b$ 之间的所有数字中 $0∼9 $的出现次数。

例如，$a=1024，b=1032$，则 $a$ 和 $b$ 之间共有 $9$ 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 $10$ 次，`1` 出现 $10$ 次，`2` 出现 $7$ 次，`3` 出现$ 3$ 次等等…

#### 输入格式

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 $a$ 和 $b$。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

#### 数据范围

$0<a,b<100000000$

#### 输入样例：

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

#### 输出样例：

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```

### 解题思路

实现一个类似前缀和思想的函数`count(n,x)`，预处理出来`1-n`中`x`出现的次数。

求`1-n`中`1`出现的次数，`n=ABCDEFG`，分别求出`x`在每一位上出现的次数，所有位相加就是`x`出现的次数。

例如，求`x`在第4位出现的次数，`1`<= `abc1def` <= `ABCDEF`。

实现这个函数就要分情况讨论：

1. 当`000`<=`abc`<=`ABC-1`，`def`可以取`000`-`999`。此时有 $ABC*1000$ 种选法。
2. 当`abc`=`ABC`且`D`<`x`，`abcxefg`一定 > `ABCDEF`。此时有 $0$ 种选法。
3. 当`abc`=`ABC`且`D`=`x`，`abcxefg`可以<=`ABCDEF`，`efg`可以取`000`-`EFG`。此时有 $EFG+1$ 种选法。
4. 当`abc`=`ABC`且`D`>`x`，`abcxefg`一定<=`ABCDEF`，`efg`可以取`000`-`999`。此时有 $1000$ 种选法。

以上四种情况结果加和，就是`1`在`第四位`上出现的次数。把所有位`1`上的次数加和，就是`1-n`中`1`出现次数。

#### 边界情况

1. 当枚举第1位上的数的时候，情况1是不存在的，只需判断符合情况2-4中的哪一种。
2. 当`x`=`0`时，特别注意，在情况1中有前导零的问题。因为我们要求的是某位为`0`出现的次数，在此位之前如果有`0`的话，这个数有前导零不存在。此时`001`<=`abc`<=`ABC-1`。
3. 当 `x=0`时，位数还要从第二位开始枚举，第一位是0的话，为前导零，无效。

```c++
#include<bits/stdc++.h>
using namespace std;

int get(vector<int> num,int l,int r)  //返回当前求的位数之前的数值是多少
{
    int res=0;
    for(int i=l;i>=r;i--)
        res=res*10+num[i];
    return res;
}

int power10(int x)
{
    int res=1;
    while(x--) res*=10;
    return res;
}

int count(int n,int x)  //从1-n当中x出现的次数
{
    if(!n) return 0;
    
    vector<int> num;  //用vector存储数
    while(n)
    {
        num.push_back(n%10);
        n/=10;
    }
    
    n=num.size();  //此时n存储的是位数
    
    int res=0;
    for(int i=n-1-!x;i>=0;i--)  //从最高位开始枚举 当x=0时，要从第2位开始枚举
    {
        if(i<n-1)  //第一中情况在枚举最高位（n-1）的时候不存在
        {
            res+=get(num,n-1,i+1)*power10(i);  //第1种情况
        	if(x==0) res-=power10(i);  //x==0的边界情况 从001到ABC-1 所以要减去1*power(i)
        }
        
        if(num[i]==x)  //第三种情况
            res+=get(num,i-1,0)+1;
        else if(num[i]>x)  //第四种情况
            res+=power10(i);
    }
    return res;
}
int main()
{
    int a,b;
    while(cin>>a>>b,a||b)  //a和b同时为0的时候停止输入
    {
        if(a>b) swap(a,b);  //小细节
        
        for(int i=0;i<10;i++)
        	cout<<count(b,i)-count(a-1,i)<<' ';
        cout<<endl;
    }
    return 0;
}
```

