## 类与对象

类是一个引用数据类型，对象是类中一个具体的实例。

从类到对象的说法有：创建一个对象、实例化一个对象、把类实例化...。

### 创建对象

```java
//直接创建
类名 对象名 = new 类名();
//先声明后创建
类名 对象名;  //声明是在内存的栈中给一个名字，没有分配
对象名 = new 类名();  //创建的过程就是在内存的堆中给对象分配一个地址
```

### 引用对象

```
对象名.成员变量;
```

### 对象创建流程

1. 先加载类信息（属性和方法信息，只会加载一次）
2. 在堆中分配对象空间, 得到对象地址
3. 成员变量进行默认初始化
4. 成员变量进行显示初始化，比如类代码中的`p.name = "Jing";`
5. 如果定义了构造方法, 成员变量根据构造方法赋值.
6. 把对象再堆中的地址返回给栈中的对象名

### 内存存在形式

![image-20230131201526665](https://cdn.jsdelivr.net/gh/chousinbin/Image/202301312015741.png)

![image-20230201133158259](https://cdn.jsdelivr.net/gh/chousinbin/Image/202302011331333.png)

![image-20230201140237179](https://cdn.jsdelivr.net/gh/chousinbin/Image/202302011402259.png)

### 样例代码

```java
public class object01 {
	public static void main (String[] args) {
		//1. new Peo(); 创建一个Peo类的对象
		//2. Peo cat1 = new Peo(); 把创建的对象赋给cat1
		Peo peo1 = new Peo();  //实例化一个Peo类的对象cat1
		
        peo1.name = "Jing";
		peo1.age = 18;
		peo1.weight = "55";

		System.out.println(peo1.name + " " + peo1.age + " " + peo1.weight);
        
        Peo peo2 = peo1;  //引用传递
        System.out.println("peo2.age=" + peo2.age);
	}
}

class Peo {
    //属性，成员变量，filed
	String name;
	int age;
	String weight;
    //构造方法
    
    //成员方法
}
```

### 匿名对象

```java
public class anonymousObject {
    public static void main(String[] args) {
        /*
         * new A08() 是匿名对象 匿名对象使用后自动释放
         * 匿名对象创建好后就可以调用其成员方法 .count1()
         */
        new A08().count1();  //10

        A08 a08 = new A08();
        a08.count2();  //9
        a08.count2();  //10
    }
}

class A08 {
    int count = 9;

    public void count1() {
        count = 10;
        System.out.println(count);
    }

    public void count2() {
        System.out.println(count++);
    }
}
```



## 成员变量

属性也叫成员变量、字段(field)。

属性不赋值的话有默认值，规则跟数组一样; 属性赋值的话, 必须且只能在声明的时候赋值, 不能先声明后赋值.

属性的定义类型为任意类型，包含基本类型和引用类型。

访问修饰符：public、protected、默认、private

```java
class 类名 {
	访问修饰符 属性类型 属性名;
	访问修饰符 属性类型 属性名 = 数据;
}
```



## 成员方法

与C/C++的函数概念类似，可以传参。方法不能嵌套定义！

### 定义

```java
访问修饰符 返回数据类型 方法名(参数列表) {
    语句;
    return 返回值;
}
```

#### 访问修饰符

控制方法的适用范围

#### 方法名

驼峰形式，能见名知义

#### 返回数据类型

任意类型。如果方法有返回数据类型，则方法末尾必须有`return 返回值;`。

#### 返回值

返回值类型必须和返回数据类型一致或兼容(int -> double)。

#### 形参列表

1. 一个方法即可以无参数也可以有多个参数，多个参数用逗号隔开。
2. 参数类型可以为任意类型，包含基本类型和引用类型
3. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容(数据类型由低向高兼容)类型的参数
4. 形式参数：方法定义时的参数；
5. 实际参数：方法调用时的参数。

### 优点

1. 提高代码的复用性
2. 可以将实现的细节封装起来，然后供其他用户调用

### 样例代码

```java
/*
创建对象调用方法,类似C++中的函数
但在Java中调用函数需先创建对象
*/
public class Method02 {
	public static void main(String[] args) {
		int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
		Tools myTools = new Tools();
		
		myTools.bianli(arr);
	}
}

class Tools {

	public void bianli(int[][] ans) {
		for(int i = 0; i < ans.length; i++)
		{
			for(int j = 0; j<ans[i].length; j++)
				System.out.print(ans[i][j] + " ");
			System.out.println();
		}
	}
}
```



## 方法调用

### 调用机制

![image-20230201155636166](https://cdn.jsdelivr.net/gh/chousinbin/Image/202302011556274.png)

从方法返回数据之后，方法在栈中就被释放了。

### 调用流程

1. 当程序执行到方法时，就会开辟一个独立的栈空间
2. 当方法执行完毕，或者执行到return语句，就会返回
3. 返回到调用方法的地方
4. 返回后继续执行方法调用后面的代码
5. 当main方法执行完毕后，整个程序退出

### 样例代码

```java
import java.util.Scanner;

public class Method01 {
	public static void main (String[] args) {
		Person Jing = new Person();
		Jing.speak();  //调用方法
		
		Jing.cal01();
		
		Jing.cal02(99);
		
		int res03 = Jing.cal03(1, 100);
		System.out.println(res03);
	}
}

class Person {
	String name;
	int age;

	//声明方法
	public void speak() {
		System.out.println("我是好人");
	}

    public void cal01() {
        int res = 0;
        for(int i = 1; i <= 100; i++)
            res += i;
        System.out.println(res);
    }

    public void cal02(int n) {
    	int res = 0;
    	for(int i = 0; i <= n; i++)
    		res += i;
    	System.out.println(res);
    }

    public int cal03(int num1, int num2) {
    	int res = 0;
    	for(int i = num1; i <= num2; i++)
    		res += i;
    	return res;
    }
}
```

### 调用规则

在同一个类中调用方法直接调用即可，不需创建一个对象。

跨类中的方法调用,需要通过对象名调用。

跨类的方法能否成功调用和方法的访问修饰符有关。

```java
public class MethodDetail {
    public static void main (String[] args) {
        B ans = new B();
        ans.print2();
    }
}

class A {  //同类调用方法
    
    public void print(int n) {
        System.out.println("n=" + n);
    }
    public void sayOk() {
        print(10);
    }
}

class B {  //跨类调用方法
    public void print2() {
        A a = new A();
        a.print(20);
    }
}
```



## 传参机制

### 基本数据类型

传递的是值(值拷贝),形参的任何改变不影响实参.

### 引用类型

传递的是地址, 可以通过形参影响实参.

### 样例代码

```java
//基本数组和数组
public class MethodParameter01 {
    public static void main(String[] args) {
        //基本数据类型
        int a = 10;
        int b = 20;
        A myA = new A();
        myA.swap(a, b);
        System.out.println("after after sawp a=" + a +  "b=" + b);  //10 20
		
        //引用数据类型
        int[] arr2 = new int[2];
        arr2[0] = 1;
        arr2[1] = 2;

        A myb = new A();
        myb.swapArr(arr2);

        for(int i = 0; i < arr2.length; i++)
            System.out.print(arr2[i] + " ");  //2 1

    }
}

class A {
    public void swap(int a, int b) {  
        int temp;
        temp = a;
        a = b;
        b = temp;
        System.out.println("after swap a=" + a +"b=" + b);  //20 10
    }

    public void swapArr(int[] arr) {  
        int temp;
        temp = arr[0];
        arr[0] = arr[1];
        arr[1] = temp;
        
        for(int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");  //2 1
        }
        System.out.println();
    }
}

```

```java
//对象传参机制
public class MethodParameter02 {
    public static void main(String[] args) {
        Person1 pp = new Person1();
        pp.age = 10;
        pp.name = "Jing";
        
        A1 mya = new A1();
        mya.test01(pp);
        System.out.println(pp.age);  //20
        mya.test02(pp);
        System.out.println(pp.age);  //20
    }
}

class Person1 {
    int age;
    String name;
}

class A1 {
    public void test01(Person1 p) {
        p.age = 20;
        /*
        对象是引用类型 实参受形参影响 
        因为两个方法里虽然对象名不同
        但是对象名都指向堆中同一个对象的地址
        */
        p = null;
        /*
        这里p只是在test01方法里的对象名 
        p指向了null 
        在main方法中的对象名指向的对象没变
        */
    }
    public void test02(Person1 p) {
        p = new Person1();
        p.age = 99;
        p.name = "Bin";
        /*
        这里p只是在test02方法里的对象名 
        p指向新的对象的地址
        那两句操作也是针对新对象的
        在main方法中的对象属性没变, 其中的对象名指向的地址也没变
        */
    }
}
```

## 方法递归

递归就是自己调用自己, 每次调用时传入不同的变量. 递归有利于编程者解决复杂问题.

### 内存结构

![image-20230207162823426](https://cdn.jsdelivr.net/gh/chousinbin/Image/202302071628517.png)

```java
public class Recursion01 {
    public static void main(String[] args) {
        Tools t1 = new Tools();

        int res = t1.factorial(5);
        System.out.println(res);
        
        int ans = t1.shulie(5);
        System.out.println(ans);
    }
    
}

class Tools {
    //递归阶乘
    public int factorial(int n) {
        if(n == 1) return 1;
        else return factorial(n - 1) * n;
    }
    //递归斐波那契数列
    public int shulie(int n) {
        if(n == 1 || n == 2) return 1;
        else return (shulie(n - 1) + shulie(n - 2));
    }
}
```

### 细节规则

1. 执行一个方法时, 就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量时独立的, 不会相互影响
3. 如果方法使用的是引用类型的变量, 就会共享该引用类型的数据
4. 递归必须有结束条件, 否则死循环
5. 当一个方法执行完毕或遇到return,就会返回. 遵守谁调用谁就将结果返回给谁, 同时当方法执行完毕或者返回时,该方法也执行完毕.

## 方法重载

java允许同一个类中存在多个同名方法, 但要求**形参列表**不一致. 

### 细节规则

1. 方法名:必须相同
2. 参数列表:参数类型或参数个数,至少有一样不同, 参数名无要求
3. 返回类型:无要求

```java
public class Overload01 {
    public static void main(String[] args) {
        MyCalculator Calculator = new MyCalculator();
        
        System.out.println(Calculator.calculate(1, 2));
        System.out.println(Calculator.calculate(1, 2.5));
        System.out.println(Calculator.calculate(1.8, 2));
        System.out.println(Calculator.calculate(1, 2, 3));
    }
}

class MyCalculator {
    //两整数之和
    public int calculate(int n1, int n2) {
        return (n1 + n2);
    }
    //整数和浮点数之和
    public double calculate(int n1, double n2) {
        return (n1 + n2);
    }
    //浮点数和整数之和
    public double calculate(double n1, int n2) {
        return (n1 + n2);
    }
    //三整数之和
    public int calculate(int n1, int n2, int n3) {
        return (n1 + n2 + n3);
    }
}
```



## 可变参数

Java中允许将同一个类中多个**同名同功能**但**参数个数不同**的方法, 封装成一个方法. 

### 细节规则

1. 可变参数的实参可以为0~$n$个
2. 参编参数的实参可以为数组
3. 可变参数的本质是数组
4. 可变参数可以和普通参数一起放在形参列表, 但可变参数必须在最后
5. 一个形参列表最多只能有一个可变参数

### 语法

 ```java
 public 返回参数类型 方法名(参数类型... 参数名) {
 	
 }
 ```

```java
public class VarParameter {
    public static void main(String[] args) {
        VP myVP = new VP();
        System.out.println(myVP.sum());
        System.out.println(myVP.sum(1, 2, 3,4));

        int[] arr1 = {4, 5, 6};
        System.out.println(myVP.sum(arr1));

        System.out.println(myVP.showScore("Sun", 90 , 80));
    }
}

class VP {
    /*
     * 返回可变参数之和
     */
    public int sum(int... n) {
        int res = 0;
        for(int i = 0; i < n.length; i++) {
            res += n[i];
        }
        return res;
    }
    /*
     * 返回学生姓名和任意门数总成绩的可变参数方法
     */
    public String showScore(String name, int... scores) {
        double res = 0;
        for(int i = 0; i < scores.length; i++) {
            res += scores[i];
        }
        return name + " " + res;
    }
    
}
```



## 作用域

全局变量:也就是属性, 作用域为整个类, 有默认值可以不赋值

局部变量:也就是方法中定义的变量, 作用域为整个方法, 无默认值必须赋值才能使用

```java
public class Scope {
    public static void main(String[] args) {
        S s1 = new S();
        s1.say();
    }
}

class S {
    String name = "Jing";  //全局变量:作用域为整个类S中
    public void say() {
        int score = 10;  //局部变量:作用域为整个方法say中
        String name = "Bin";
        System.out.println("sayName = " + name);
    }
}
```

### 命名细节

1. 成员变量与局部变量可以重名, 访问时遵循就近原则
2. 同一个方法里, 局部变量不能重名

### 作用范围

全局变量/属性:可以在本类中使用, 也可以通过对象调用的方式从其他类中使用

局部变量:只能在本类中对应的方法中使用

### 修饰符相关

全局变量/属性:可以加修饰符

局部变量:不可以加修饰符



## 构造方法

构造方法/构造器可以在创建对象的时候完成对新对象属性的初始化

### 细节规则

1. 构造器的修饰符可以默认
2. 构造器没有返回值
3. **方法名**与**类**名必须一致
4. 参数和成员方法规则一样
5. 创建对象的同时, 系统自动调用该类的构造方法
6. 构造器是完成对象的初始化, 不是创建对象
7. 构造方法可以重载, 利用不同的构造方法
8. 如果程序员没有定义构造器, 系统会自动给类生成一个默认无参构造器(默认构造器)
9. 一旦定义了自己的构造器, 默认的构造器失效, 就不能在使用无参构造器, 除非再显示定义一下

```java
public class constructor {
    /*
     * 要求
     * 利用构造方法
     * 实现
     * 创建人类对象的同时
     * 指定对象年龄和姓名
     */
    public static void main(String[] args) {
        Person p1 = new Person("Jing", 18);
        System.out.println(p1.name + " " + p1.age);

        Person p2 = new Person("Bin");
        System.out.println(p2.name + " " + p2.age);

        /*
         * 定义构造方法之后创建对象必须传参
         * 因为定义构造方法之后默认无参构造方法失效
         * 想要不传参就必须在类中显示声明默认无参构造方法
         */
        Person p3 = new Person(); 
        System.out.println(p3.name + " " + p3.age);
    }
}

class Person {
    //属性
    String name;
    int age;

    //构造方法1
    public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
    }
    
    //构造方法2
    public Person(String pName) {
        name = pName;
    }

    //默认无参构造方法0
    Person(){}
}
```



## this

> 如果构造方法参数列表里面的参数名和对象的成员变量名相同, 会看起来美观方便. 但是根据作用域原则, 会导致成员变量无法被成功赋值. 关键字`this`能解决这个问题. 

Java虚拟机会为每个对象分配`this`, 用于代表当前对象, this关键字可以用来访问本类的属性(用于区分当前类的属性和局部变量)、方法、构造器.this不能在类定义的外部使用, 只能在类定义的方法中使用

### 访问成员方法

`this.方法名(参数列表);`

### 访问构造方法

`this(参数列表);`

只能在构造方法内使用, 并且必须是构造方法中的第一个语句, 一个构造方法里最多使用一次this访问构造方法



```java
public class This {
    public static void main(String[] args) {
        People p1 = new People("Jing", 18);
        System.out.println(p1.name + " " + p1.age);

        People p2 = new People();
        System.out.println(p2.name + " " + p2.age);
    }
}

class People {
    String name;
    int age;

    public People() {
        this("THIS", 99);//只能在构造方法内使用
    }
    
    public People(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

![image-20230212135009596](https://cdn.jsdelivr.net/gh/chousinbin/Image/202302121350749.png)

