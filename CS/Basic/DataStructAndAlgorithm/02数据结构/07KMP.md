# KMP算法



#### 问题描述

给定一个模式串 $S$，以及一个模板串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串 $P$ 在模式串 $S$ 中多次作为子串出现。

求出模板串 $P$ 在模式串 $S$ 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 $N$，表示字符串 $P$ 的长度。

第二行输入字符串 $P$。

第三行输入整数 $M$，表示字符串 $S$ 的长度。

第四行输入字符串 $S$。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。

#### 数据范围

$1≤N≤10$^5^
$1≤M≤10$^6^

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=1e6+10;
int n,m;
char p[N],s[M];//p是模板串 s
int ne[N];

int main()
{
    //s和p从1开始存储
    cin>>n>>p+1>>m>>s+1;
    //构造ne 求最长公共前后缀 的 后缀的尾下标
    for(int i=2,j=0;i<=n;i++)
    {
       	while(j && p[i]!=p[j+1]) j=ne[j];
        if(p[i]==p[j+1]) j++;
        ne[i]=j;
    }
    //求子序列的头坐标
    for(int i=1,j=0;i<=m;i++)
    {
        //单个不匹配的循环处理
        while(j && s[i]!=p[j+1]) j=ne[j];
        //单个匹配就向后推进
        if(s[i]==p[j+1]) j++;
        //完全匹配
        if(j==n)
        {
            cout<<i-n<<' ';
            j=ne[j];//为寻找下一个子序列做准备
        }
    }
    return 0;
}

```

