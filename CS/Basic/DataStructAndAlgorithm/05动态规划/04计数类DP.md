# 05x04计数类DP



## 整数划分

一个正整数 $n$ 可以表示成若干个正整数之和，形如：$n=n1+n2+…+nk$，其中 $n1≥n2≥…≥nk,k≥1$。

我们将这样的一种表示称为正整数 $n$ 的一种划分。

现在给定一个正整数 $n$，请你求出 $n$ 共有多少种不同的划分方法。

#### 输入格式

共一行，包含一个整数 $n$。

#### 输出格式

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 $10^9+7$ 取模。

#### 数据范围

$1≤n≤1000$



### 类完美背包解法

我们可以把本问题看做成，一个背包容量为 $n$ ，物品的体积分别为 $1,2,3...n$，恰好装满$n$的方案总数。**（完全背包变形）**

#### 状态表示

`f[i][j]`：从`1~i`中选，体积总和为`j`（恰好装满背包）的方案数。

#### 转移方程

`f[i][j]=f[i-1][j]+f[i][j-1]`

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=1e9+7;
int n;
int f[N][N];
int main()
{
    cin>>n;
    
    f[0][0]=1;//  初始化
    
    for(int i=1;i<=n;i++)
        for(int j=0;j<=n;j++)
        {
            f[i][j]=f[i-1][j] % M;  //不选第i个
            if(j>=i) f[i][j]=(f[i][j]+f[i-1][j-i]) % M;  //当容量大于i的时候才纠结选几个i
        }   
    
    cout<<f[n][n];
    return 0;
}
```

#### 关于初始化`f[i][0]=1`

动态规划的本质就是从小推到大的，虽然我们代码里是从`1`开始的，但是状态转移带有`[i-1]`之类，所以在具体的计算中会用到`0`这种情况。那么为什么是总和为$0$，方案数却是$1$呢？就是，当背包体积为`0`时，我们只能选择一个$0$，所以方案数为$1$。

其实朴素做法只需要初始化`f[0][0]=1`这种情况就好了，因为在计算后面的情况时，`f[i][0]`都会因为体积不够导致只能从`f[i-1][0]`这种状态转移过来，即`f[i][0]=f[i-1][0]`。

#### 一维优化

`f[j]=f[j]+f[j-i]`

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=1e9+7;
int n;
int f[N];

int main()
{
    cin>>n;
    
    f[0]=1;
    
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            f[j]=(f[j]+f[j-i]) % M;
        
    cout<<f[N];
    return 0;
   
}
```





