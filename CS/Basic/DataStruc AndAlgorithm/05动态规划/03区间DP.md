# 05x03区间DP

状态表示的是某个区间。



## 石子合并

### 问题描述

设有 $N$ 堆石子排成一排，其编号为 $1，2，3，…，N1，2，3，…，N$。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 $4$ 堆石子分别为 `1 3 5 2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1，2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；

如果第二步是先合并 $2，3$ 堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。

问题是：找出一种合理的方法，使总的代价最小，**输出最小代价**。

#### 状态表示

`f[i][j]`表示下标`i~j`区间

集合：所有将第`i`到第`j`堆石子合并成一堆石子的合并方式

属性：所有合并方式的代价的最小值

#### 状态计算

以最后一次合并的分界线分类。分界线`k`左边有`1`个、`2`个、`3`个...`n-1`个这么多状态。
按照区间长度从小到大枚举，枚举起点，自动获得终点，再按照分界线进行取最小值，最后输出`f[1][n]`。

#### 常用模版

第一维都是枚举区间长度，一般 `len = 2` 用来初始化，第二维枚举起点 `i` （右端点 `j `自动获得，`j = i + len - 1`）。

两个区间$[l,k]\ [k+1,r]$

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=510;
int f[N][N];
int n;
int a[N],s[N];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s[i]=s[i-1]+a[i];
    }
   	//len表示区间长度
    for(int len=2;len<=n;len++)
    {
        for(int i=1;i+len-1<=n;i++)  //枚举起点
        {
            int l=i,r=i+len-1;  //r为终点
            f[l][r]=1e8;  //求最小代价 所以要把每个区间初始化为一个最大值
            for(int k=l;k<r;k++)  //k表示在分界线左边的那堆石子的最右边的石子的下标
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
        }
    }
    
    cout<<f[1][n];
    return 0;
}
```

#### 为什么先枚举长度呢？

每个状态只会依赖比它长度更短的其他状态，所以先枚举长度可以保证在计算每个状态之前，先计算出它所依赖的状态。

#### 为什么还要加上`l`到`r`的区间和？

区间和表示最后一次合并所需要的代价。
