# 双指针算法

## 从字符串中提取单词

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string str;
    getline(str,cin);
    
    int len=str.size();
    for(int i=0;i<len;i++)
    {
        int j=i;
        while(j<n && str[j]!=' ') j++;
        
        for(int k=i;k<j;k++) cout<<str[i];
        cout<<endl;
        
        i=j;
    }
    
}
```

## 最长连续不重复子序列

如果暴力算法时间复杂度为 $O(n^2)$, 我们采用双指针时间复杂度为 $O(n)$

$i$指针从头开始往右走, $j$ 指针从 $0$开始往又走, 每遍历一次$i$ 子串往右扩展一位, 扩展的时候用$cnt[]$数组标记子串中数字出现的次数, 每扩展完一位根据 $cnt[]$判断当前子串是否重复, 如果重复就要从子串的左端点($j$指向的位置)开始向右逐位缩短子串, 直到子串中没有重复数字;此时就是以$j$指向的位置为结尾的最长不重复子序列, 每找到一个子序列就用$res$更新一下最长连续不重复子序列的最大长度;最后输出$res$;

向右扩展一位只能使最大长度加一或者出现重复子序列的情况; 出现重复子序列的情况时, 因为每向右扩展一位之前从$j$到$i-1$指向的区间已经是以$i$为结尾的连续不重复的子序列, 所以是刚扩展的位重复了, 所以只能从当前子序列的左端点逐步往右缩短才能够使以$i$为结尾的子序列不重复;

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,q[N],cnt[N];

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>q[i];

    int res=0;
    for(int i=1,j=1;i<=n;i++)
    {
        cnt[q[i]]++;
        
        /*关键：指针i往右走 只要下标为i的元素出现次数大于1 
        就要从j开始往右走直到整个子序列不重复*/
        while(j<i && cnt[q[j]]>1)  
        {
            cnt[q[j]]--;
            j++;
        }
        res=max(res,i-j+1);
    }
    cout<<res;
    return 0;
}
```

## 最长连续子序列

可以重复 但是子序列元素种数不能超过 $k$ 输出首尾下标

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10,;
int n,k;
int a[N],cnt[M];

int main()
{
    cin>>n>>k;
    
    for(int i=1;i<=n;i++) cin>>a[i];
    
    int res=0,l,r;
    for(int i=1,j=1,t=0;i<=n;i++)
    {
        if(cnt[a[i]]==0) t++;
        cnt[a[i]]++;
        
        while(t>k)
        {
            if(cnt[a[j]]==1) t--;
            cnt[a[j]]--;
            j++;
        }
        
        if(i-j+1>res)
        {
            res=i-j+1;
            l=j,r=i;
        }
    }
    cout<<l<<' '<<r;
    return 0;
}
```

