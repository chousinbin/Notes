# 单链表

单链表有一种形式叫邻接表，用来存储数和图。

#### 问题描述

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 $k$ 个插入的数后面的数；
3. 在第 $k$ 个插入的数后插入一个数。

现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第  $1 $个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。

#### 输入格式

第一行包含整数 $M$，表示操作次数。

接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 $x$。
2. `D k`，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。
3. `I k x`，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int head;//头节点指向头节点的下标
int e[N];//结点的数值
int ne[N];//结点的下一个点的下标
int idx;//链表长度
//初始化单链表
void init()
{
    head=-1;
    idx=0;
}
//在头节点后插入x
void add_head(int x)
{
    e[idx]=x;
    ne[idx]=head;
    head=idx;
    idx++;
}

//在下标为k的数后插入x
void add(int k,int x)
{
    e[idx]=x;
    ne[idx]=ne[k];
    ne[k]=idx;
    idx++;
}
//删除下标为k的点的后一个结点
void remove(int k)
{
    ne[k]=ne[ne[k]];
}
int main()
{
    init();
    int n;
    cin>>n;
    
    while(n--)
    {
        int k,x;//第k个结点的下标是k-1
        char z;
        cin>>z;
        
        if(z=='H'){
            cin>>x;
            add_head(x);
        }else if(z=='D'){
            cin>>k;
            if(!k) head=ne[head];
            else remove(k-1);
        }else{
            cin>>k>>x;
            add(k-1,x);
        }
    }
    for(int i=head;i!=-1;i=ne[i]) cout<<e[i]<<' ';
    return 0;
}
```







