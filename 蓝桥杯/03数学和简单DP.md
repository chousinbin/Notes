## 蚂蚁感冒

两个蚂蚁相撞掉头等价为穿过彼此继续前行。

### 性质（起始感冒蚂蚁向右情况）

1. 初始感冒蚂蚁右边向右走的不会被感染，
2. 左边的蚂蚁向左走的不会被感染。
3. 如果右边有向左走的则右边向左走的和左边向右走的均会被感染。
4. 如果右边没有向左走的则没有其他的蚂蚁会被感染。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int g[N];

int main()
{
    int n;
    cin>>n;

    for(int i=1;i<=n;i++)
        cin>>g[i];

    int left=0,right=0;
    for(int i=1;i<=n;i++)
    {
        if(abs(g[i])>abs(g[1]) && g[i]<0) right++;
        if(abs(g[i])<abs(g[1]) && g[i]>0) left++;
    }
    
    if(g[1]<0 && left==0 || g[1]>0 && right==0) cout<<1;
    else cout<<left+right+1;
    
    return 0;
}
```

## 地宫取宝

X 国王有一个地宫宝库，是 $n×m$ 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

#### 输入格式

第一行 $3$ 个整数，$n,m,k$，含义见题目描述。

接下来 $n$ 行，每行有 $m$ 个整数 $Ci$ 用来描述宝库矩阵每个格子的宝贝价值。

#### 输出格式

输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。

该数字可能很大，输出它对 $1000000007$ 取模的结果。

#### 数据范围

$1≤n,m≤50$,
$1≤k≤12$,
$0≤Ci≤12$



### 解题思路

#### 状态表示 

#### $f[i][j][k][c]$。集合：所有从起点走到 $(i,j)$ ，并且取了 $k$ 件物品，且最后一件物品的价值是 $c$ 的合法方案的集合。属性：数量。

#### 状态计算





```c++
#include<bits/stdc++.h>
using namespace std;
const int N=55,mod=1000000007;
int n,m,k;
int w[N][N];
int f[N][N][13][14];

int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>w[i][j];
            w[i][j]++;  //物品价值的取值范围是0~12 我们手动改成1~13 把0作为一个边界点
        }
    }    
        
    //第一个选或不选都算是一种方案
    f[1][1][1][w[1][1]]=1;
    f[1][1][0][0]=1;
    
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i==1 && j==1) continue;
            for(int u=0;u<=k;u++)
            {
                for(int v=0;v<=13;v++)
                {
                 
                    //不取
                    f[i][j][u][v]=(f[i][j][u][v]+f[i][j-1][u][v])%mod;
                    f[i][j][u][v]=(f[i][j][u][v]+f[i-1][j][u][v])%mod;
                    //取
				    if(u>0 && v==w[i][j])  //u为0的意思就是一个都不取  当满足c=w[i][j]的时候才能取 因为要取的数是当前最大的
                    {
                        for(int c=0;c<v;c++)
                        {
                            f[i][j][u][v]=(f[i][j][u][v]+f[i-1][j][u-1][c])%mod;
                            f[i][j][u][v]=(f[i][j][u][v]+f[i][j-1][u-1][c])%mod;
                        }
                  	}
                }
            }
        }
    }

    int res=0;
    for(int i=0;i<=13;i++)  //把每种结果都累加一下
    {
        res=(res+f[n][m][k][i])%mod;
    }
    cout<<res;

    return 0;
}
```



## 波动数列



### 解法

$a_n=a_{n-1}+d_i$ ，$d=a或-b$ 。那么数列就是，$x,x+d_1,x+d_1+d_2,x+d_1+d_2+d_3,...,+x+d_1+d_2+...+d_{n-1}$，整理得，$nx+(n-1)d_1+(n-2)d_2+...+d_{n-1}=s$。

再转化，$x=\frac {s-((n-1)d_1+(n-2)d_2+...+d_{n-1})}{n}$。

因为 $x$ 是整数，所以 $s\ mod\ n$ 与 $(s-((n-1)d_1+(n-2)d_2+...+d_{n-1}))\ mod\ n$ 相等。

### 状态表示

`f[i][j]`所有只考虑前 $i$ 项，且当前的数列之和 % $n$ 是 $j$ 的方案的数量。

### 状态计算

第 $i$ 次选择的时候第 $i$ 个数可以选择加 $a$ 或减 $b$ 。

如果选加 $a$，那么前 $i$ 个数的和为：$[(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}+(n−i)a]$

再计算，$[(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}+(n−i)a]\ \%\ n\ ≡\ j\ \%\ n$。

转化后，$(n−1)d_1 +(n−2)d_2 +…+(n−(i−1))d_{i−1}\ ≡\ j−(n−i)a$。

所以，$f[i][j]\ =\ f[i-1][j-(n-i)*a\ \%\ n]$ 。

同理选减$b$,$f[i][j]\ =\ f[i-1][j+(n-i)*b\ \%\ n]$ 。

综上状态计算最终表达式：$f[i][j]=f[i-1][j-(n-i)*a\ \%\ n]\ +\ f[i-1][j+(n-i)*b\ \%\ n]$

##### 最后$f[n-1][get\_mod(n,s)]$的解释。

序列的长度是 $n$，若当前第一个数是$x$，需要组合 $n - 1$个数，才变成$S$，所以相当于求从前$n - 1$个项中选，余数是 $s\ \%\ n$的方案数。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010,mod=100000007;
int dp[N][N];
int get_mod(int a,int b)
{
    return (a%b+b) % b;
}
int main()
{
    int n,s,a,b;
    cin>>n>>s>>a>>b;

    dp[0][0]=1;

    for(int i=1;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            dp[i][j]=(dp[i-1][get_mod(j-a*(n-i),n)] + dp[i-1][get_mod(j+b*(n-i),n)]) % mod;
        }
    }

    cout<<dp[n-1][get_mod(s,n)];
    return 0;
}
```

