

# 最大公约数

## 等差数列

数学老师给小明出了一道等差数列求和的题目。

但是粗心的小明忘记了一部分的数列，只记得其中 $N$ 个整数。

现在给出这 $N$ 个整数，小明想知道包含这 $N$ 个整数的最短的等差数列有几项？

#### 输入格式

输入的第一行包含一个整数 $N$。

第二行包含 $N$ 个整数 $A1,A2,⋅⋅⋅,AN$。(注意 $A1∼AN$ 并不一定是按等差数列中的顺序给出)

#### 输出格式

输出一个整数表示答案。

#### 数据范围

$2≤N≤100000$,
$0≤Ai≤10^9$

#### 解题思路

为了使整个等差数列最短，$l = \frac{a_{max}-a_{min}}{d}+1$，所以公差应该最大。 $d$ 的最大值等于原数列中第 $2-n$ 个数与 $a_1$ 的差值的最大公约数。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    
    if(a[n-1]==a[0])  //特判
    {
        cout<<n;
        return 0;
    }
    
    int res=0;  //0和任何数的最大公约数都是任何数
    for(int i=1;i<n;i++)
    {
        res=gcd(res,a[i]-a[0]);
    }
    
    cout<<(a[n-1]-a[0])/res+1;
    return 0;
}
```

# 算术基本定理

任何一个数都能写成质因数次幂乘积的形式，形如 $N = p_1^{a_1}·p_2^{a_2}·p_3^{a_3}···p_k^{a_k}$ ，$p_i$为质数。例如，$ 12=2^2 · 3^1$。

## X的因子链

输入正整数 $X$，求 $X$ 的大于 $1$ 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。

#### 输入格式

输入包含多组数据，每组数据占一行，包含一个正整数表示 $X$。

#### 输出格式

对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。

每个结果占一行。

#### 数据范围

$1≤X≤2^{20}$

#### 解题思路

对于一个数 $X$ ，如果写成

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=(1<<20)+10;  //相当于2的20次幂加10
typedef long long LL;

int primes[N],cnt;
bool st[N];
int minp[N];  //minp[i] 存放i的最小质因子

void get_primes(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])
        {
            primes[cnt++]=i;
            minp[i]=i;
        }
        for(int j=0;primes[j]*i<=n;j++)
        {
            st[primes[j]*i]=true;
            minp[primes[j]*i]=primes[j];
            if(i%primes[j]==0) break;
        }
    }
}

int main()
{
    get_primes(N-1);

    int fact[30];  //每个因子都是2的时候最多有20个质因子 存储质分解出来的质因子
    int sum[N];  //存储某个质因子的个数

    int x;
    while(scanf("%d",&x) != -1)
    {
        int k=0,tot=0;  //k为质因子的种属  tot为总共质因子的个数
        while(x!=1)
        {
            int p=minp[x];  //把x的最小质因子取出来
            fact[k]=p;  //存储一下质因子
            sum[k]=0;
            while(x%p==0)
            {
                x/=p;
                tot++;
                sum[k]++; 
            }
            k++;  //这种质因子用完了 下一次是另一种了
        }
        
        LL res=1;
        for(int i=1;i<=tot;i++) res*=i;  //先求出质因子个数的阶乘

        for(int i=0;i<k;i++)
        {
            for(int j=1;j<=sum[i];j++)
            {
                res/=j;  //res再除每种质因子的个数的阶乘 就等于排列数
            }
        }

        cout<<tot<<' '<<res<<endl;
    }
    return 0;
}

```



# 约数

$N$ 必然满足算术基本定理， $N = p_1^{a_1}·p_2^{a_2}·p_3^{a_3}···p_k^{a_k}$，那么就有 $N$ 的

约数个数: $(a_1+1)(a_2+1)(a_3+1)···(a_k+1)$

约数之和: $(p_1^0+p_1^1+...+p_1^{a_1})(p_2^0+p_2^1+...+p_2^{a_2})···(p_k^0+p_k^1+...+p_k^{a_k})$







