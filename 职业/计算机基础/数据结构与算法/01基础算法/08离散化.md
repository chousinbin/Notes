# 离散化



## 离散化

### 特点

数据范围比较大，数据个数比较少。

### 问题

需要去除有重复元素

二分查找算出序列元素 $x$ 离散化后的值（下标） 

## 区间和

### 题目描述

假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。

现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。

接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。

### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 nn 行，每行包含两个整数 xx 和 cc。

再接下来 mm 行，每行包含两个整数 ll 和 rr。

### 输出格式

共 mm 行，每行输出一个询问中所求的区间内数字和。

### 数据范围

$−10$^9^≤ $x$ ≤$10$^9^
$1$≤ $n,m$ ≤$10$^5^
$−10$^9^≤ $l≤r$ ≤$10$^9^
$−10000≤c≤10000$

### 输入样例

```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```

### 输出样例

```
8
0
5
```

### AC代码

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N=3e6+10;
int a[N],s[N];
int n,m;
vector<int> alls;
vector<PII> add,query;
//二分查找 x的离散化后的下标
int find(int x)
{
    int l=0,r=alls.size()-1;
    while(l<r)
    {
        int mid=l+r>>1;
        if(alls[mid]>=x) r=mid;
        else l=mid+1;
    }
    return r+1;//加1 因为前缀和从1开始
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        int x,c;
        cin>>x>>c;
        add.push_back({x,c});
        alls.push_back(x);
    }
    for(int i=0;i<m;i++)
    {
        int l,r;
        cin>>l>>r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
        //此处插入l和r 是为了再求区间和时能找到这左右端点
    }
    //去重
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());
    //插入c
    for(int i=0;i<add.size();i++)
    {
        int x=find(add[i].first);
        a[x]+=add[i].second;
    }
    //前缀和
    for(int i=1;i<=alls.size();i++) s[i]=s[i-1]+a[i];
    //区间和
    for(int i=0;i<query.size();i++)
    {

        int l=find(query[i].first),r=find(query[i].second);
        cout<<s[r]-s[l-1]<<endl;
    }
    return 0;
}
```

