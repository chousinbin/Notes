# STL



## unordered_map

unordered_map 容器，直译过来就是"无序 map 容器"的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。

> 对于已经学过 map 容器的读者，可以将 unordered_map 容器等价为无序的 map 容器。

具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。

值得一提的是，unordered_map 容器在`<unordered_map>`头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：

```c++
#include <unordered_map>
using namespace std;
```

> 注意，第二行代码不是必需的，但如果不用，则后续程序中在使用此容器时，需手动注明 `std` 命名空间（强烈建议初学者使用）。

| 成员方法      | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| begin()       | 返回指向容器中第一个键值对的正向迭代器。                     |
| end()         | 返回指向容器中最后一个键值对之后位置的正向迭代器。           |
| empty()       | 若容器为空，则返回 true；否则 false。                        |
| size()        | 返回当前容器中存有键值对的个数。                             |
| operator[key] | 该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。 |
| find(key)     | 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
| count(key)    | 在容器中查找以 key 键的键值对的个数。                        |
| insert()      | 向容器中添加新键值对。                                       |
| erase()       | 删除指定键值对。                                             |
| clear()       | 清空容器，即删除容器中存储的所有键值对。                     |
| swap()        | 交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 |

### 遍历

#### 迭代器遍历

```c++
int main()
{
    unordered_map<int,int> a;
    for(auto i=a.begin();i!=a.end();i++)
    {
        cout<<a->first<<' '<<b->second<<endl;
    }
}
```



## unordered_set